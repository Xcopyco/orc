<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_audit.js.html":{"id":"lib_audit.js.html","title":"Source: lib/audit.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/audit.js 'use strict'; const { Writable: WritableStream } = require('stream'); const assert = require('assert'); const crypto = require('crypto'); const constants = require('./constants'); const MerkleTree = require('mtree'); const utils = require('./utils'); /** * Represents a streaming audit challenge generator */ class Audit extends WritableStream { /** * @constructor * @param {number} audits - Total number of challenges to generate */ constructor(audits) { super(); assert(typeof audits === 'number', 'Invalid number of audits supplied'); assert(!Number.isNaN(audits), 'Invalid number of audits supplied'); assert(Number.isFinite(audits), 'Invalid number of audits supplied'); this._audits = audits; this._finished = false; this._challenges = []; this._inputs = this._prepareChallenges(); this.on('finish', this._generateTree.bind(this)); } /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ getPublicRecord() { assert(this._finished, 'Challenge generation is not finished'); return this._tree.level(this._tree.levels() - 1) .map((i) =&gt; i.toString('hex')); } /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ getPrivateRecord() { assert(this._finished, 'Challenge generation is not finished'); return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges.map((i) =&gt; i.toString('hex')) }; } /** * Implements the underlying write method * @private */ _write(bytes, encoding, next) { this._inputs.forEach((input, i) =&gt; { if (i &lt; this._audits) { input.update(bytes); } }); next(); } /** * Prepares the challenge hasher instances * @private */ _prepareChallenges() { let iterations = 0; let inputs = []; while (iterations &lt; this._audits) { const challenge = this._generateChallenge(); const input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return inputs; } /** * Generate the audit merkle tree from a series of challenges * @private */ _generateTree() { this._finished = true; this._tree = new MerkleTree(this._inputs.map((input, i) =&gt; { if (i &gt;= this._audits) { return input; } else { return utils.rmd160sha256(utils.rmd160(input.digest())); } }), utils.rmd160sha256); } /** * Generate a random challenge buffer * @private * @returns {buffer} */ _generateChallenge() { return crypto.randomBytes(constants.AUDIT_BYTES); } /** * Create a challenge response input to merkle tree * @private */ _createResponseInput(challenge) { return crypto.createHash('sha256').update(challenge); } /** * Returns a new instance from the predefined challenges and tree * @param {array} challenges - The precomputed challenges * @param {array} tree - The bottom leaves of the existing merkle tree * @returns {Audit} */ static fromRecords(challenges, tree) { assert(Array.isArray(challenges), 'Invalid challenges supplied'); assert(Array.isArray(tree), 'Invalid tree supplied'); assert( tree.length === utils.getNextPowerOfTwo(challenges.length), 'Challenges and tree do not match' ); tree = tree.map((i) =&gt; Buffer.from(i, 'hex')); const auditor = new Audit(challenges.length); auditor._challenges = challenges; auditor._tree = new MerkleTree(tree, utils.rmd160sha256); auditor._finished = true; return auditor; } } module.exports = Audit; × Search results Close "},"lib_bridge.js.html":{"id":"lib_bridge.js.html","title":"Source: lib/bridge.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/bridge.js 'use strict'; const BusBoy = require('busboy'); const ReedSolomon = require('@ronomon/reed-solomon'); const Zcash = require('zcash'); const http = require('http'); const utils = require('./utils'); const fs = require('fs'); const merge = require('merge'); const connect = require('connect'); const auth = require('basic-auth'); const crypto = require('crypto'); const { tmpdir } = require('os'); const path = require('path'); const tiny = require('tiny'); const mkdirp = require('mkdirp'); const uuid = require('uuid'); const AuditStream = require('./audit'); const Contract = require('./contract'); /** * Represents a local HTTP(s) server that abstracts the upload and download * of files away to a simple request. Files are encrypted to the given public * key, split into shards for erasure codes. Prepped for distribution and * queued for storing in the network. Bridge exposes a simple API for getting * status of transfers and previously stored objects. * * GET / (List objects as JSON) * GET /{hash} (Download object) * DELETE /{hash} (Delete object) * POST / (Upload object - Multipart) */ class Bridge { static get DEFAULTS() { return { auth: { user: null, pass: null }, store: path.join( tmpdir(), `objects.${crypto.randomBytes(16).toString('hex')}` ), stage: path.join( tmpdir(), `staging.${crypto.randomBytes(16).toString('hex')}` ), capacityCache: null, auditInterval: 432000000 // 5 days }; } /** * @constructor * @param {Node} node */ constructor(node, options) { this.options = merge(Bridge.DEFAULTS, options); this.objects = tiny(this.options.store); this.node = node; this.server = http.createServer(this.createRequestHandler()); if (!fs.existsSync(this.options.stage)) { mkdirp.sync(this.options.stage); } setInterval(() =&gt; this.audit(), 21600000); // 6 hours } /** * Listens on the given port and hostname * @param {number} port * @param {string} hostname * @param {function} callback */ listen() { this.server.listen(...arguments); } /** * Creates request router and handler stack * @returns {function} */ createRequestHandler() { const handler = connect(); handler.use(this.authenticate.bind(this)); handler.use('/', this.route.bind(this)); handler.use(this.error.bind(this)); return handler; } /** * Handles request authentication if defined * @param {object} request * @param {object} response * @param {function} next */ authenticate(req, res, next) { const { user, pass } = this.options.auth; const error = new Error('Not authorized'); error.code = 401; if (user &amp;&amp; pass) { const creds = auth(req); if (!(creds.name === user &amp;&amp; creds.pass === pass)) { return next(error); } } next(); } /** * Responds to requests with error code and message * @param {error} error * @param {object} request * @param {object} response * @param {function} next */ error(err, req, res, next) { if (!err) { return next(); } res.writeHead(err.code); res.write(err.message); res.end(); } /** * Handles routing requests to their appropriate handler * @param {object} request * @param {object} response * @param {function} next */ route(req, res, next) { const { method, url } = req; function badRequest() { let error = new Error(`Cannot ${method} ${url}`); error.code = 400; next(error); } if (method === 'POST') { if (url !== '/') { badRequest(); } else { this.upload(req, res, next); } } else if (method === 'GET') { if (url === '/') { this.list(req, res, next); } else { this.download(req, res, next); } } else if (method === 'DELETE') { if (url === '/') { badRequest(); } else { this.destroy(req, res, next); } } else { badRequest(); } } /** * Scans the object database and returns all index entries * @param {object} request * @param {object} response * @param {function} next */ list(req, res, next) { let written = 0; res.writeHead(200, { 'Content-Type': 'application/json' }); res.write('[') this.objects.each((obj) =&gt; { res.write((written === 0 ? '' : ',') + JSON.stringify(obj)); written++; }); res.write(']'); res.end(); } /** * Queues the object for upload to the network * @param {object} request * @param {object} response * @param {function} next */ upload(req, res, next) { res.writeHead(501); res.end('Not Implemented'); const busboy = new BusBoy({ headers: req.headers }); const objects = []; busboy.on('file', (field, file, name, encoding, mime) =&gt; { const tmp = path.join(this.options.stage, uuid.v4()); mkdirp.sync(tmp); let size = 0; const hash = crypto.createHash('sha256'); const hasher = new stream.Transform({ transform: (data, enc, cb) =&gt; { size += data.length; hash.update(data); cb(null, data); } }); const writer = fs.createWriteStream(path.join(tmp, 'ciphertext')); const cipher = utils.createCipher(this.node.spartacus.publicKey, this.node.spartacus.privateKey); file.pipe(hasher).pipe(cipher).pipe(writer).on('finish', () =&gt; { const digest = hash.digest('hex'); const stage = path.join(this.options.stage, digest); const ciphertext = path.join(stage, 'ciphertext'); fs.renameSync(tmp, stage); objects.push({ hash: digest, encoding, mimetype: mime }); this.distribute(ciphertext, { encoding, mimetype: mime }); this.objects.save(digest, { name, encoding, mimetype: mime, hash: digest, size, status: 'queued', shards: [] }, () =&gt; null); }); }); busboy.on('finish', () =&gt; { res.writeHead(201, { 'Content-Type': 'application/json' }); res.write(JSON.stringify(objects)); res.end(); }); req.pipe(busboy); } /** * Takes the supplied file path and applies erasure codes, then attempts to * distribute the shards across the network * @param {string} filepath - Path to the file to distribute * @param {object} metadata * @param {string} metadata.encoding * @param {string} metadata.mimetype * @param {string} metadata.hash * @returns {EventEmitter} */ distribute(filepath, metadata) { const stat = fs.statSync(filepath); const rsparams = utils.getErasureParameters(stat.size); const rs = new ReedSolomon(rsparams.shards, rsparams.parity); function encodeErasure(callback) { fs.readFile(filepath, (err, file) =&gt; { if (err) { return callback(err); } let parity = []; let { size } = rsparams; for (let i = 0; i &lt; rsparams.parity; i++) { parity.push(new Buffer(rsparams.size)); } file = Buffer.concat([file, Buffer.concat(parity)]); rs.encode(file, 0, file.length, size, 0, size, (err) =&gt; { if (err) { return callback(err); } this.objects.get(metadata.hash, (err, object) =&gt; { if (err) { return callback(err); } else { callback(null, file, rsparams, object); } }); }); }); } function prepareShards(file, rsparams, object, callback) { let time = Date.now(); let shards = []; let position = 0; function prepareContracts() { async.eachSeries(shards, (shard, next) =&gt; { const audit = new AuditStream(3); // TODO: Configurable const stream = fs.createReadStream(shard.path); const hash = crypto.createHash('sha256'); const hasher = new stream.Transform({ transform: (data, enc, cb) =&gt; { hash.update(data); cb(null, data); } }); stream.pipe(hasher).pipe(audit).on('finish', () =&gt; { shard._audits = audit.getPrivateRecord(); shard._proposal = Contract.from({ data_hash: utils.rmd160(hash.digest()).toString('hex'), data_size: rsparams.size, audit_count: 3, // TODO: Configurable audit_leaves: audit.getPublicRecord(), payment_storage_price: 0, // TODO: Configurable payment_download_price: 0, // TODO: Configurable store_begin: time, store_end: time + ms('90d'), // TODO: Configurable renter_hd_key: this.node.contact.xpub, renter_hd_index: this.node.contact.index, renter_id: this.node.identity.toString('hex') }); shard._proposal.sign('renter', this.node.spartacus.privateKey); next(); }); }, () =&gt; { object.shards = shards; this.object.save(object.hash, object, () =&gt; callback(null, object)); }); } async.times(rsparams.shards + rs.params.parity, (n, done) =&gt; { const pad = (n) =&gt; n &gt;= 10 ? n.toString() : `0${n}`; const shardpath = path.join(path.dirname(filepath), `${pad(n)}.shard`); fs.writeFile(shardpath, file.slice(position, rsparams.size), () =&gt; { position += rsparams.size; shards.push({ index: n, size: rsparams.size, path: shardpath }); done(); }); }, () =&gt; { fs.unlink(filepath, () =&gt; prepareContracts()); }); } function uploadShards(shards, object, callback) { // TODO: Publish or claim a contract for each shard // TODO: Upload each shard to respective farmer node // TODO: Keep object pointer updated for retrieval later callback(null); } async.waterfall([ (next) =&gt; encodeErasure(next), (file, rs, obj, next) =&gt; prepareShards(file, rs, obj, next), (shards, obj, next) =&gt; uploadShards(shards, obj, next) ], (err) =&gt; { this.node.logger.error(err.message); }); } /** * Downloads the object from the network * @param {object} request * @param {object} response * @param {function} next */ download(req, res, next) { res.writeHead(501); res.end('Not Implemented'); // TODO: Lookup object and get shard pointers // TODO: Request a download token for each shard // TODO: Download each shard (minimum RS?) // TODO: Respond to request with decrypted stream } /** * Ends contracts with farmers for the object parts and removes * reference to them * @param {object} request * @param {object} response * @param {function} next */ destroy(req, res, next) { res.writeHead(501); res.end('Not Implemented'); // TODO: For each shard referenced by the object // TODO: Set the store_end time in the contract to now // TODO: Issue a RENEW message to the associated farmer node // TODO: Issue any final payment for storage // TODO: Remove the object reference // TODO: Respond immediately after queuing the destroy // TODO: (Status can be checked with GET /) } /** * Periodically call this to scan the object store for shards that need to * be audited, perform audit, and issue payment * @param {function} callback */ audit(callback) { callback(new Error('Auditor not implemented')); } } module.exports = Bridge; × Search results Close "},"lib_contract.js.html":{"id":"lib_contract.js.html","title":"Source: lib/contract.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/contract.js 'use strict'; const ms = require('ms'); const merge = require('merge'); const JSONSchema = require('jsen'); const stringify = require('json-stable-stringify'); const constants = require('./constants'); const utils = require('./utils'); const secp256k1 = require('secp256k1'); const { utils: keyutils } = require('kad-spartacus'); /** * Represents a storage contract between a renter and a farmer */ class Contract { /** * @constructor * @param {object} contract * @param {string} contract.type - Unique identifier for the contract * @param {string} [contract.renter_hd_key] - Node extended public key in base58 * @param {number} [contract.renter_hd_index] - Derivation index for signature * @param {string} contract.renter_id - Node ID of the renter * @param {string} contract.renter_signature - Renter's cryptographic signature * @param {string} [contract.farmer_hd_key] - Node extended public key in base58 * @param {number} [contract.farmer_hd_index] - Derivation index for signature * @param {string} contract.farmer_id - Node ID of the farmer * @param {string} contract.farmer_signature - Farmer's cryptographic signature * @param {number} contract.data_size - Number of bytes to store * @param {string} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {number} contract.store_begin - UNIX timestamp to start contract * @param {number} contract.store_end - UNIX timestamp to end the contract * @param {number} contract.audit_count - Number of audits renter will perform * @param {string[]} contract.audit_leaves - Merkle leaves for audit tree * @param {number} contract.payment_storage_price - Total price for storage * @param {number} contract.payment_download_price - Price per download * @param {string} contract.payment_destination - Zcash address to send funds * @param {object} criteria * @param {number} criteria.size - Criteria degree OPCODE * @param {number} criteria.duration - Criteria degree OPCODE * @param {number} criteria.availability - Criteria degree OPCODE * @param {number} criteria.speed - Criteria degree OPCODE */ constructor(contract, criteria) { this._properties = merge(Contract.DEFAULTS, contract); this._criteria = this._inferCriteria(criteria); this._clean(); } /** * Defines the JSON Schema of a {@link Contract} * @static */ static get schema() { return { type: 'object', properties: { version: { type: ['integer'], minimum: 0 }, renter_hd_key: { type: ['string', 'boolean'], pattern: '^[1-9a-km-zA-HJ-NP-Z]{1,111}$' }, renter_hd_index: { type: ['integer', 'boolean'], minimum: 0, maximum: 2147483647 }, renter_id: { type: ['string', 'null'], pattern: '[A-Fa-f0-9]{40}$' }, renter_signature: { type: ['string', 'null'] }, farmer_hd_key: { type: ['string', 'boolean'], pattern: '^[1-9a-km-zA-HJ-NP-Z]{1,111}$' }, farmer_hd_index: { type: ['integer', 'boolean'], minimum: 0, maximum: 2147483647 }, farmer_id: { type: ['string', 'null'], pattern: '[A-Fa-f0-9]{40}$' }, farmer_signature: { type: ['string', 'null'] }, data_size: { type: ['integer', 'null'], minimum: 0 }, data_hash: { type: ['string', 'null'], pattern: '^[0-9a-f]{40}$' }, store_begin: { type: ['integer', 'null'], minimum: 0 }, store_end: { type: ['integer', 'null'], minimum: 0 }, audit_count: { type: ['integer', 'null'], minimum: 0 }, audit_leaves: { type: 'array', items: { type: 'string', pattern: '[A-Fa-f0-9]$' } }, payment_storage_price: { type: ['integer', 'null'] }, payment_download_price: { type: ['integer', 'null'] }, payment_destination: { type: ['string', 'null'] } } }; } /** * Validation function against the schema * @static */ static get validator() { return JSONSchema(Contract.schema); } /** * Defines some default properties of a {@link Contract} * @static */ static get DEFAULTS() { return { version: 1, renter_hd_key: false, renter_hd_index: false, renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, audit_leaves: [], payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; } /** * Defines some default criteria of a {@link Contract} * @static */ static get CRITERIA() { return { size: constants.OPCODE_DEG_MED, duration: constants.OPCODE_DEG_MED, availability: constants.OPCODE_DEG_MED, speed: constants.OPCODE_DEG_MED }; } /** * Defines the criteria matrix for a {@link Contract} * @static */ static get MATRIX() { return { size: function(size) { if (size &gt; 0 &amp;&amp; size &lt;= (32 * 1024 * 1024)) { return constants.OPCODE_DEG_LOW; } if (size &gt; (32 * 1024 * 1024) &amp;&amp; size &lt;= (512 * 1024 * 1024)) { return constants.OPCODE_DEG_MED; } if (size &gt; (512 * 1024 * 1024) &amp;&amp; size &lt;= (4096 * 1024 * 1024)) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, duration: function(duration) { if (duration &gt; 0 &amp;&amp; duration &lt;= ms('30d')) { return constants.OPCODE_DEG_LOW; } if (duration &gt; ms('30d') &amp;&amp; duration &lt;= ms('90d')) { return constants.OPCODE_DEG_MED; } if (duration &gt; ms('90d') &amp;&amp; duration &lt;= ms('320d')) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, availability: function(availability) { if (availability &gt;= 0.5 &amp;&amp; availability &lt;= 0.7) { return constants.OPCODE_DEG_LOW; } if (availability &gt; 0.7 &amp;&amp; availability &lt;= 0.9) { return constants.OPCODE_DEG_MED; } if (availability &gt; 0.9 &amp;&amp; availability &lt;= 1) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, speed: function(speed) { if (speed &gt; 0 &amp;&amp; speed &lt;= 6) { return constants.OPCODE_DEG_LOW; } if (speed &gt; 6 &amp;&amp; speed &lt;= 12) { return constants.OPCODE_DEG_MED; } if (speed &gt; 12 &amp;&amp; speed &lt;= 32) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; } }; } /** * Removes all properties not in the schema from contract * @private * @param {object} criteria - Criteria degree opcodes * @returns {object} */ _inferCriteria(criteria) { let opcodes = Contract.CRITERIA; opcodes.size = Contract.MATRIX.size(this.get('data_size')); opcodes.duration = Contract.MATRIX.duration( this.get('store_end') - this.get('store_begin') ); return merge(opcodes, criteria); } /** * Removes all properties not in the schema from contract * @private * @returns {Contract} */ _clean() { const keys = Object.keys(Contract.schema.properties); for (let field in this._properties) { if (!keys.includes(field)) { delete this._properties[field]; } } return this; } /** * Validates the contract specification * @private * @returns {boolean} validity */ isValid() { return Contract.validator(this._properties); } /** * Checks if the contract is complete * @returns {boolean} completed */ isComplete() { for (let prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; } /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @returns {string} */ getSigningData() { const sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); } /** * Signs the contract as the given actor * @param {string} actor - One of 'farmer' or 'renter' * @param {buffer} secret - ECDSA private key * @returns {string} signature */ sign(actor, secret) { return this.set(actor + '_signature', this.signExternal(secret).toString('base64')); } /** * Verify the contract signature for the given actor * @param {string} actor - One of 'farmer' or 'renter' * @returns {boolean} */ verify(actor) { const compactSig = Buffer.from(this.get(`${actor}_signature`), 'base64'); const recovery = compactSig[0]; const signature = compactSig.slice(1); const message = utils.sha256(Buffer.from(this.getSigningData())); const pubkey = secp256k1.recover(message, signature, recovery, true); const pubkeyhash = this.get(`${actor}_id`); return this.verifyExternal(signature, pubkey) &amp;&amp; keyutils.toPublicKeyHash(pubkey).toString('hex') === pubkeyhash; } /** * Signs the contract with the proved key and returns the signature * @param {buffer} secret - ECDSA private key * @returns {buffer} */ signExternal(secret) { const { signature, recovery } = secp256k1.sign( utils.sha256(Buffer.from(this.getSigningData())), secret ); return Buffer.concat([Buffer.from([recovery]), signature]); } /** * Verify the provided signature for the contract * @param {buffer} signature - The contract signature to verify * @param {buffer} pubkey - ECDSA public key * @returns {boolean} */ verifyExternal(signature, pubkey) { return secp256k1.verify( utils.sha256(Buffer.from(this.getSigningData())), signature, pubkey ); } /** * Applies the provided fields to the contract and validates it * @param {object} fields - Contract properties to update * @returns {Contract} */ update(fields) { for (let prop in fields) { this.set(prop, fields[prop]); } return this; } /** * Returns the value for the given contract property * @param {string} field - Contract property to get * @returns {string|number|null} value */ get(field) { return this._properties[field]; } /** * Sets the contract property to the given value * @param {string} field - Contract property to set * @param {string|number} value - Value to set for field * @returns {string|number|null} */ set(field, value) { this._properties[field] = value; this._clean(); return this._properties[field]; } /** * Calculates the SHA-256 hash of the serialized contract * @returns {buffer} */ getHash() { return utils.sha256(this.toBuffer()); } /** * Return OPCODE byte sequence for contract publication topic * @returns {buffer} */ getTopicBuffer() { return Contract.createTopic(this._criteria); } /** * Return OPCODE byte sequence for contract publication topic as hex string * @returns {string} */ getTopicString() { return this.getTopicBuffer().toString('hex'); } /** * Converts the contract to a plain object * @returns {object} */ toObject() { return JSON.parse(this.toJSON()); } /** * Converts the contract to JSON string * @returns {string} */ toJSON() { return stringify(this._properties); } /** * Converts the contract to Buffer * @returns {buffer} */ toBuffer() { return new Buffer(this.toJSON(), 'utf8'); } /** * Creates a contract from a plain object * @static * @param {object} object - Dictionary of contract data * @returns {Contract} */ static fromObject(object) { return new Contract(object); } /** * Creates a contract from a JSON string * @param {string} json - JSON encoded contract * @returns {Contract} */ static fromJSON(json) { return new Contract(JSON.parse(json)); } /** * Creates a contract from a Buffer * @param {buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ static fromBuffer(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); } /** * Infers the type of object supplied and constructs a contract * @param {object|string|buffer} data * @returns {Contract} */ static from(data) { if (data instanceof Contract) { return Contract.fromObject(data.toObject()); } else if (Buffer.isBuffer(data)) { return Contract.fromBuffer(data); } else if (typeof data === 'string') { return Contract.fromJSON(data); } else { return Contract.fromObject(data); } } /** * Create a topical OPCODE byte sequence from the provided criteria * @param {object} criteria * @param {number} criteria.size - Criteria degree OPCODE * @param {number} criteria.duration - Criteria degree OPCODE * @param {number} criteria.availability - Criteria degree OPCODE * @param {number} criteria.speed - Criteria degree OPCODE * @returns {buffer} */ static createTopic(criteria) { criteria = merge(Contract.CRITERIA, criteria); return new Buffer([ constants.OPCODE_CONTRACT_PREFIX, criteria.size, criteria.duration, criteria.availability, criteria.speed ]); } /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {boolean} */ static compare(c1, c2) { const contract1 = c1.toObject(); const contract2 = c2.toObject(); const ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); } /** * Returns the property names between two contracts that differ * @param {Contract} c1 - Contract to compare * @param {contract} c2 - Contract to compare * @returns {string[]} changedProperties */ static diff(c1, c2) { const differs = []; c1 = c1.toObject(); c2 = c2.toObject(); for (let prop in c1) { if (Array.isArray(c1[prop])) { if (JSON.stringify(c1[prop]) !== JSON.stringify(c2[prop])) { differs.push(prop); } } else if (c1[prop] !== c2[prop]) { differs.push(prop); } } return differs; } } module.exports = Contract; × Search results Close "},"lib_profiles.js.html":{"id":"lib_profiles.js.html","title":"Source: lib/profiles.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/profiles.js /** * @module orc/profiles */ 'use strict'; const async = require('async'); const ms = require('ms'); const bytes = require('bytes'); const Contract = require('./contract'); const Audit = require('./audit'); const Proof = require('./proof'); const Bridge = require('./bridge'); const constants = require('./constants'); const utils = require('./utils'); const Zcash = require('zcash'); const tiny = require('tiny'); /** * Base class for a profile, sets up zcash wallet and other shared profile * behavior */ class Profile { /** * @constructor * @param {Node} node * @param {object} config */ constructor(node, config) { this.node = node; this.config = config; this.wallet = this._createWallet(); this._init(); } /** * Generates a new zcash address * @param {Profile~getNewAddressCallback} callback */ getNewAddress(callback) { if (parseInt(this.config.WalletShieldedTransactions)) { this.wallet.z_getnewaddress() .then((addr) =&gt; callback(null, addr), callback); } else { this.wallet.getnewaddress() .then((addr) =&gt; callback(null, addr), callback); } } /** * @callback Profile~getNewAddressCallback * @param {error|null} error * @param {string} address */ /** * Creates a zcash wallet instance * @private */ _createWallet() { return new Zcash({ username: this.config.WalletUser, password: this.config.WalletPassword, port: parseInt(this.config.WalletPort), host: this.config.WalletHostname }); } /** * Initializes the profile * @private */ _init() {} } /** * Applies the farmer profile to the supplied node. A farmer publishes capacity * announcements, subscribes to contract publications, and reaps stale shards. */ class FarmerProfile extends Profile { /** * @constructor * @param {Node} node * @param {object} config */ constructor(node, config) { super(node, config); } /** * @private */ _init() { this.node.logger.info( `subscribing to ${this.config.FarmerAdvertiseTopics.length} topic codes` ); this.node.subscribeShardDescriptor( this.config.FarmerAdvertiseTopics, (err, rs) =&gt; { if (err) { this.node.logger.warn(err.message); } else { rs.on('data', (data) =&gt; this._handleContract(...data)); } } ); this.announceCapacity(); setInterval(() =&gt; this.announceCapacity(), ms(this.config.FarmerAnnounceInterval)); setInterval(() =&gt; this.reapExpiredShards(), ms(this.config.FarmerShardReaperInterval)); } /** * Handles incoming contract publications and sends storage offer * @private * @param {object} contract * @param {array} contact */ _handleContract(contract, contact) { contract = Contract.from(contract); this.getNewAddress((err, addr) =&gt; { if (err) { this.node.logger.error(err.message); return this.node.logger.warn( 'cannot send offer for shard, failed to get new address from wallet' ); } contract.set('farmer_id', this.node.identity.toString('hex')); contract.set('farmer_hd_key', this.node.contact.xpub); contract.set('farmer_hd_index', this.node.contact.index); contract.set('payment_destination', addr); contract.sign('farmer', this.node.spartacus.privateKey); contract = contract.toObject(); this.node.offerShardAllocation(contact, contract, (err) =&gt; { if (err) { this.node.logger.info(`offer rejected, reason: ${err.message}`); } else { this.node.logger.info( `acquired storage contract ${contract.data_hash} ` + `from renter node ${contact[0]}` ); } }); }); } /** * Announces current storage capacity to neighbors * @param {FarmerProfile~announceCapacityCallback} callback */ announceCapacity(callback = () =&gt; null) { this.node.shards.size((err, data) =&gt; { if (err) { return this.node.logger.warn('failed to measure capacity'); } async.eachSeries(this.config.FarmerAdvertiseTopics, (topic, next) =&gt; { this.node.publishCapacityAnnouncement(topic, data, (err) =&gt; { if (err) { this.node.logger.error(err.message); this.node.logger.warn('failed to publish capacity announcement'); } else { this.node.logger.info('published capacity announcement ' + `${data.available}/${data.allocated}` ); } next(); }); }, callback); }); } /** * @callback FarmerProfile~announceCapacityCallback * @param {error|null} error */ /** * Scans the contract database for expired shards and reaps them from storage * @param {FarmerProfile~reapExpiredShardsCallback} callback */ reapExpiredShards(callback = () =&gt; null) { const time = Date.now(); const rs = this.node.contracts.createReadStream(); this.node.logger.info('starting contract database scan for stale shards'); rs.on('data', ({ key, value }) =&gt; { let contract = Contract.from(value); if (contract.get('end_time') &lt; (time + ms('24h'))) { this.node.shards.unlink(contract.get('data_hash'), (err) =&gt; { if (err) { this.node.logger.warn(`failed to reap shard ${value.data_hash}`); } else { this.node.logger.info(`unlinked stale shard ${value.data_hash}`); this.node.contracts.del(key, () =&gt; rs.resume()); } }); } else { rs.resume(); } }); rs.on('end', () =&gt; { this.node.logger.info('finished reaping stale shards'); callback(null); }); rs.on('error', (err) =&gt; { this.node.logger.error(err.message); this.node.logger.warn('did not complete reaping stale shards'); callback(err); }); } /** * @callback FarmerProfile~reapExpiredShardsCallback * @param {error|null} error */ } /** * Applies the renter profile to the supplied node. A renter listens for * capacity announcements and keeps a cache, exposes a local bridge for * upload/download, handles auditing, mirroring, and payments. */ class RenterProfile extends Profile { /** * @constructor * @param {Node} node * @param {object} config */ constructor(node, config) { super(node, config); this.capacity = tiny(config.RenterCapacityCachePath); } /** * Exposes the capacity cache over the control port * @param {RenterProfile~getCapacityCacheCallback} callback */ getCapacityCache(callback) { this.capacity.find({})(callback); } /** * @private */ _init() { this.node.logger.info('subscribing to network capacity announcements'); this.node.subscribeCapacityAnnouncement( this.config.RenterListenTopics, (err, rs) =&gt; { rs.on('data', ([available, contact]) =&gt; { let timestamp = Date.now(); this.capacity.set(contact[0], { available, contact, timestamp }); }); } ); if (!parseInt(this.config.BridgeEnabled)) { return; } let opts = { store: this.config.BridgeMetaStoragePath, stage: this.config.BridgeTempStagingBaseDir, auditInterval: ms(this.config.BridgeShardAuditInterval), capacityCache: this.capacity }; if (parseInt(this.config.BridgeAuthenticationEnabled)) { opts.auth = { user: this.config.BridgeAuthenticationUser, pass: this.config.BridgeAuthenticationPassword }; } this.bridge = new Bridge(opts); this.node.logger.info( 'establishing local bridge at ' + `${this.config.BridgeHostname}:${this.config.BridgePort}` ); this.bridge.listen(parseInt(this.config.BridgePort), this.config.BridgeHostname); } } /** * Applies the farmer profile * @function * @param {Node} node * @param {object} config * @returns {FarmerProfile} */ module.exports.farmer = function(node, config) { node.profiles = node.profiles || {}; node.profiles.farmer = new FarmerProfile(node, config); return node.profiles.farmer; }; /** * Applies the renter profile * @function * @param {Node} node * @param {object} config * @returns {RenterProfile} */ module.exports.renter = function(node, config) { node.profiles = node.profiles || {}; node.profiles.renter = new RenterProfile(node, config); return node.profiles.renter; }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: index.js /** * @module orc * @license AGPL-3.0 */ 'use strict'; const { spawn } = require('child_process'); const { join } = require('path'); /** * Forks a child orc process and returns the child process and a controller * client for sending commands to it * @function * @param {object|string} config - Configuration properties as object or path * to a configuration file. See {@tutorial config} for details. * connect to the control port * @returns {object} */ /* istanbul ignore next */ module.exports = function(config = {}) { /* eslint max-statements: [2, 18] */ const cport = config.ControlPort || require('./bin/_config').ControlPort; const caddr = config.ControlPort || require('./bin/_config').ControlHostname; const controller = new module.exports.control.Client(); let envs = {}; let args = [join(__dirname, './bin/orc.js')]; let trys = 10; let opts = { env: envs }; if (typeof config === 'string') { args = args.concat(['--config', config]); } else { for (let prop in config) { envs[`orc_${prop}`] = config[prop]; } } const child = spawn(process.execPath, args, opts); function connect() { controller.once('error', () =&gt; { controller.removeAllListeners(); if (trys !== 0) { trys--; setTimeout(connect, 1000); } }); controller.on('ready', () =&gt; controller.removeAllListeners('error')); controller.connect(cport, caddr); } process.on('exit', () =&gt; child.kill()); child.stdout.once('data', () =&gt; setTimeout(() =&gt; connect(), 1000)); child.stderr.once('data', (msg) =&gt; child.emit('error', new Error(msg))); return { child, controller }; }; /** {@link Node} */ module.exports.Node = require('./lib/node'); /** {@link Rules} */ module.exports.Rules = require('./lib/rules'); /** {@link Transport} */ module.exports.Transport = require('./lib/transport'); /** {@link Server} */ module.exports.Server = require('./lib/server'); /** {@link Audit} */ module.exports.Audit = require('./lib/audit'); /** {@link Proof} */ module.exports.Proof = require('./lib/proof'); /** {@link Offers} */ module.exports.Offers = require('./lib/offers'); /** {@link Shards} */ module.exports.Shards = require('./lib/shards'); /** {@link Contract} */ module.exports.Contract = require('./lib/contract'); /** {@link Bridge} */ module.exports.Bridge = require('./lib/bridge'); /** {@link module:orc/constants} */ module.exports.constants = require('./lib/constants'); /** {@link module:orc/profiles} */ module.exports.profiles = require('./lib/profiles'); /** {@link module:orc/utils} */ module.exports.utils = require('./lib/utils'); /** {@link module:orc/version} */ module.exports.version = require('./lib/version'); /** @see https://github.com/bookchin/boscar */ module.exports.control = require('boscar'); × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/constants.js /** * @module orc/constants */ 'use strict'; module.exports = { /** * @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** * @constant {Number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 86400000, /** * @constant {Number} CONSIGN_THRESHOLD - Threshold for consign time */ CONSIGN_THRESHOLD: 86400000, /** * @constant {Number} TOKEN_EXPIRE - Reject datachannl token after time */ TOKEN_EXPIRE: 1800000, /** * @constant {Number} OFFER_TIMEOUT - Max wait time for storage offer */ OFFER_TIMEOUT: 15000, /** * @constant {Number} OPCODE_CONTRACT_PREFIX - Prefix opcode for contracts */ OPCODE_CONTRACT_PREFIX: 0x0f, /** * @constant {Number} OPCODE_DEG_NULL - Opcode for null criteria degree */ OPCODE_DEG_NULL: 0x00, /** * @constant {Number} OPCODE_DEG_LOW - Opcode for low criteria degree */ OPCODE_DEG_LOW: 0x01, /** * @constant {Number} OPCODE_DEG_MED - Opcode for medium criteria degree */ OPCODE_DEG_MED: 0x02, /** * @constant {Number} OPCODE_DEG_HIGH - Opcode for medium criteria degree */ OPCODE_DEG_HIGH: 0x03, /** * @constant {Number} MAX_CONCURRENT_OFFERS - Number of concurrent offers */ MAX_CONCURRENT_OFFERS: 3, /** * @constant {Number} MAX_CONCURRENT_AUDITS - Number of concurrent audits */ MAX_CONCURRENT_AUDITS: 3, /** * @constant MAX_NODE_INDEX - Maximum node index */ MAX_NODE_INDEX: 0x7fffffff, /** * @constant HD_KEY_DERIVATION_PATH - Key derivation path for HD keys */ HD_KEY_DERIVATION_PATH: 'm/3000\\'/0\\'' }; × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/utils.js /** * @module orc/utils */ 'use strict'; const https = require('https'); const stream = require('stream'); const assert = require('assert'); const secp256k1 = require('secp256k1'); const HDKey = require('hdkey'); const constants = require('./constants'); const crypto = require('crypto'); const semver = require('semver'); const ip = require('ip'); /** * Returns the SHA-256 hash of the input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.sha256 = function(input, encoding) { return crypto.createHash('sha256').update(input, encoding).digest(); }; /** * Returns the RIPEMD-160 hash of the input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.rmd160 = function(input, encoding) { return crypto.createHash('rmd160').update(input, encoding).digest(); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.rmd160sha256 = function(input, encoding) { return module.exports.rmd160(module.exports.sha256(input, encoding)); }; /** * Returns the next power of two number * @param {number} number * @returns {number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Returns a stringified URL from the supplied contact object * @param {array} contact * @param {string} contact.0 - Node identity key * @param {object} contact.1 * @param {string} contact.1.hostname * @param {string} contact.1.port * @param {string} contact.1.protocol * @returns {string} */ module.exports.getContactURL = function(contact) { const [identity, info] = contact; return `${info.protocol}//${info.hostname}:${info.port}/${identity}`; }; /** * Returns whether or not the supplied semver tag is compatible * @param {string} version - The semver tag from the contact * @returns {boolean} */ module.exports.isCompatibleVersion = function(version) { const local = require('./version').protocol; const remote = version; const sameMajor = semver.major(local) === semver.major(remote); const diffs = ['prerelease', 'prepatch', 'preminor', 'premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else { return sameMajor; } }; /** * Determines if the supplied contact is valid * @param {array} contact - The contact information for a given peer * @param {boolean} loopback - Allows contacts that are localhost * @returns {boolean} */ module.exports.isValidContact = function(contact, loopback) { const [, info] = contact; const isValidAddr = ip.isV4Format(info.hostname) || ip.isV6Format(info.hostname) || ip.isPublic(info.hostname); const isValidPort = info.port &gt; 0; const isAllowedAddr = ip.isLoopback(info.hostname) ? !!loopback : true; return isValidPort &amp;&amp; isValidAddr &amp;&amp; isAllowedAddr; }; /** * Determines if a value is hexadecimal string * @param {*} a - The value to be tested * @returns {boolean} */ module.exports.isHexaString = function(a) { if (typeof a !== 'string') { return false; } return /^[0-9a-fA-F]+$/.test(a); }; /** * Checks if the supplied HD key is valid (base58 encoded) and proper length * @param {string} hdKey - The HD key in base 58 encoding * @returns {boolean} isValidHDKey */ module.exports.isValidHDNodeKey = function(hdKey) { return typeof hdKey === 'string' &amp;&amp; /^[1-9a-km-zA-HJ-NP-Z]{1,111}$/.test(hdKey); }; /** * Checks if the input is a non-hardened HD key index * @param {number} hdIndex - The HD key index * @returns {boolean} isValidHDKeyIndex */ module.exports.isValidNodeIndex = function(n) { return !Number.isNaN(n) &amp;&amp; (parseInt(n) === n) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= constants.MAX_NODE_INDEX; }; /** * Returns a HD key object using corrent key derivation path using the * given seed * @param {buffer} seed64 - 64 byte seed for generating key * @returns {HDKey} */ module.exports.createComplexKeyFromSeed = function(seed64) { assert(Buffer.isBuffer(seed64), 'Seed must be a buffer'); assert(seed64.length === 64, 'Seed must be 64 bytes in length'); var hdKey = HDKey.fromMasterSeed(seed64).derive( constants.HD_KEY_DERIVATION_PATH ); return hdKey.privateExtendedKey; }; /** * Returns a request object for uploading a shard to a farmer * @param {array} farmer - Farmer contact object * @param {string} hash - The hash of the shard to upload * @param {string} token - The authorized transfer token * @returns {https.ClientRequest} */ module.exports.createShardUploader = function(farmer, hash, token) { const [, contact] = farmer; function _createUploadStream() { return https.request({ method: 'POST', rejectUnauthorized: false, protocol: contact.protocol, hostname: contact.hostname, port: contact.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream' } }); } return new stream.Transform({ transform: function(chunk, encoding, callback) { /* istanbul ignore else */ if (!this._uploader) { this._uploader = _createUploadStream(); this._uploader.on('response', this.emit.bind(this, 'response')); this._uploader.on('error', (err) =&gt; { this.unpipe(); this.emit('error', err); }); } this._uploader.write(chunk, encoding, callback); }, flush: function(callback) { /* istanbul ignore else */ if (this._uploader) { this._uploader.end(); } callback(); } }); }; /** * Returns a request object for downloading a shard from a farmer * @param {array} farmer - Farmer contact object * @param {string} hash - The hash of the shard to upload * @param {string} token - The authorized transfer token * @returns {https.ClientRequest} */ module.exports.createShardDownloader = function(farmer, hash, token) { const [, contact] = farmer; function _createDownloadStream() { return https.get({ rejectUnauthorized: false, protocol: contact.protocol, hostname: contact.hostname, port: contact.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream' } }); } return new stream.Readable({ read: function() { if (!this._downloader) { this._downloader = _createDownloadStream(); this._downloader.on('response', (res) =&gt; { res .on('data', this.push.bind(this)) .on('error', this.emit.bind(this, 'error')) .on('end', this.push.bind(this, null)); }) .on('error', this.emit.bind(this, 'error')); } } }); }; /** * Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret * derived from the given public and private keys * @param {buffer} publicKey - SECP256k1 public key bytes * @param {buffer} privateKey - SECP256k1 private key bytes * @returns {object} */ module.exports.createCipher = function(publicKey, privateKey) { const secret = secp256k1.ecdh(publicKey, privateKey); const cipher = crypto.createCipher('aes-256-cbc-hmac-sha256', secret); return cipher; }; /** * Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret * derived from the given public and private keys * @param {buffer} publicKey - SECP256k1 public key bytes * @param {buffer} privateKey - SECP256k1 private key bytes * @returns {object} */ module.exports.createDecipher = function(publicKey, privateKey) { const secret = secp256k1.ecdh(publicKey, privateKey); const decipher = crypto.createDecipher('aes-256-cbc-hmac-sha256', secret); return decipher; }; /** * Returns the appropriate shard size, number of shards, and number of parity * shards for RS encoding/decoding provided the total number of bytes of the * complete content * @param {number} n - Number of bytes in data * @returns {object} */ module.exports.getErasureParameters = function(n) { let size = 8 * (1024 * 1024); let params = { shards: 2, parity: 1, length: n, get size() { return params.length / params.shards; } }; function accumulate() { if (n &gt; size &amp;&amp; params.shards !== 16 &amp;&amp; params.parity !== 8) { size = size * 4; params.shards = params.shards * 2; params.parity = params.parity * 2; return accumulate(); } else { return params; } } return accumulate(); }; × Search results Close "},"lib_version.js.html":{"id":"lib_version.js.html","title":"Source: lib/version.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/version.js /** * @module orc/version */ 'use strict'; var semver = require('semver'); var assert = require('assert'); var postfix = process.env.ORC_NETWORK ? `-${process.env.ORC_NETWORK}` : ''; module.exports = { /** * @constant {string} protocol - The supported protocol version */ protocol: '2.0.0' + postfix, /** * @constant {string} software - The current software version */ software: require('../package').version, /** * Returns human readable string of versions * @function * @returns {string} */ toString: function() { let { software, protocol } = module.exports; return `orc v${software} protocol v${protocol}`; } }; assert( semver.valid(module.exports.protocol), 'Invalid protocol version specified' ); × Search results Close "},"lib_node.js.html":{"id":"lib_node.js.html","title":"Source: lib/node.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/node.js 'use strict'; const url = require('url'); const { Readable: ReadableStream } = require('stream'); const { createLogger } = require('bunyan'); const merge = require('merge'); const { KademliaNode } = require('kad'); const quasar = require('kad-quasar'); const spartacus = require('kad-spartacus'); const constants = require('./constants'); const https = require('https'); const Contract = require('./contract'); const OfferStream = require('./offers'); const Rules = require('./rules'); const Server = require('./server'); const Transport = require('./transport'); /** * Extends Kademlia with Orc protocol rules * @license AGPL-3.0 */ class Node extends KademliaNode { static get DEFAULTS() { return { logger: createLogger({ name: 'storj' }), transport: new Transport(), privateExtendedKey: null, keyDerivationIndex: 1, contracts: null, shards: null, claims: [] }; } /** * @constructor * @extends {KademliaNode} * @param {object} options * @param {string} options.privateExtendedKey - HD extended private key * @param {object} [options.logger] - Bunyan compatible logger * @param {object} [options.transport] - Orc transport adapter * @param {object} options.contracts - Levelup compatible contract store * @param {object} options.shards - KFS compatible shard database * @param {string[]} [options.claims] - Enable direct capacity claims from * the given public extended keys * @param {number} [options.keyDerivationIndex] - HD derivation index */ constructor(options) { const opts = merge(Node.DEFAULTS, options); super(merge(Node.DEFAULTS, options)); this.quasar = this.plugin(quasar); this.spartacus = this.plugin(spartacus(options.privateExtendedKey, options.keyDerivationIndex, constants.HD_KEY_DERIVATION_PATH)); this.offers = new Map(); this.contracts = opts.contracts; this.shards = opts.shards; this.server = new Server({ contracts: this.contracts, shards: this.shards, identity: this.identity }); this.claims = opts.claims; this.transport.on('identify', (req, res) =&gt; { this.logger.debug('responding to peer requested identification'); res.end(JSON.stringify([ this.identity.toString('hex'), this.contact ])); }); this.transport.on('download', (req, res) =&gt; { this.logger.debug('handling shard download request'); this.server.download(req, res) }); this.transport.on('upload', (req, res) =&gt; { this.logger.debug('handling shard upload request'); this.server.upload(req, res) }); } /** * Adds the kademlia rule handlers before calling super#listen() */ listen() { let handlers = new Rules(this); this.use('OFFER', handlers.offer.bind(handlers)); this.use('AUDIT', handlers.audit.bind(handlers)); this.use('CONSIGN', handlers.consign.bind(handlers)); this.use('MIRROR', handlers.mirror.bind(handlers)); this.use('RETRIEVE', handlers.retrieve.bind(handlers)); this.use('PROBE', handlers.probe.bind(handlers)); this.use('RENEW', handlers.renew.bind(handlers)); this.use('CLAIM', handlers.claim.bind(handlers)); super.listen(...arguments); } /** * Sends a GET request to the URI and parses the result as a valid * contact object with identity * @param {string} url - The URL of the node * @param {Node~identifyServiceCallback} callback */ identifyService(uri, callback) { const options = merge(url.parse(uri), { agent: this.onion.createSecureAgent(), method: 'GET' }); const req = https.request(options, (res) =&gt; { let body = ''; res.on('error', callback); res.on('data', (data) =&gt; body += data.toString()); res.on('end', () =&gt; { if (res.statusCode !== 200) { callback(new Error(body)); } else { try { callback(null, JSON.parse(body)); } catch (err) { callback(new Error('Failed to parse identity')); } } }); }); req.on('error', callback); req.end(); } /** * @callback Node~identifyServiceCallback * @param {error|null} error * @param {array} contact */ /** * Requests authorization tokens to pull file shard(s) from another node * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {string[]} hashes - Hashes of the shards to pull * @param {Node~authorizeRetrievalCallback} callback */ authorizeRetrieval(peer, hashes, callback) { this.send('RETRIEVE', hashes, peer, callback); } /** * @callback Node~authorizeRetrievalCallback * @param {error|null} error * @param {string[]} retrievalTokens */ /** * Requests authorization tokens to push file shard(s) to another node * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {string[]} hashes - Hashes of the shards to push * @param {Node~authorizeConsignmentCallback} callback */ authorizeConsignment(peer, hashes, callback) { this.send('CONSIGN', hashes, peer, callback); } /** * @callback Node~authorizeConsignmentCallback * @param {error|null} error * @param {string[]} consignmentTokens */ /** * Requests the source node to MIRROR a shard to the supplied destination * @param {array} source * @param {string} source.0 - Identity key string * @param {string|object} source.1 - Address data for contact * @param {object} target * @param {array} target.destination - * @param {string} target.destination.0 - Identity key string * @param {string|object} target.destination.1 - Address data for contact * @param {string} target.hash - Hash of the shard to mirror * @param {string} target.token - Authorization token to PUSH shard * @param {Node~createShardMirrorCallback} callback */ createShardMirror(source, target, callback) { this.send('MIRROR', [target.hash, target.token, target.destination], source, callback); } /** * @callback Node~createShardMirrorCallback * @param {object|null} error */ /** * Sends the series of hash/challenge pairs to the remote node to request * proof-of-storage * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object[]} audits * @param {string} audits.hash - Hash of the shard to prove * @param {string} audits.challenge - Challenge string to prepend to shard * @param {Node~auditRemoteShardsCallback} callback */ auditRemoteShards(peer, audits, callback) { this.send('AUDIT', audits, peer, callback); } /** * @callback Node~auditRemoteShardsCallback * @param {object|null} error * @param {object[]} proofs * @param {string} proofs.hash - Hash of the shard for corresponding proof * @param {string} proofs.proof - {@tutorial compact-merkle-proof} */ /** * Publishes a storage contract proposal to the network and exposes a stream * of received OFFER messages * @param {object} contract - See {@tutorial storage-contracts} for format * @param {object} [offerStreamOptions] - See {@link OfferStream} * @param {Node~publishShardDescriptorCallback} callback */ publishShardDescriptor(contract, options, callback) { contract = Contract.from(contract); /* istanbul ignore else */ if (typeof options === 'function') { callback = options; options = {}; } const routingKey = contract.get('data_hash'); const topicString = contract.getTopicString(); const offerStream = new OfferStream(contract, options); const descriptor = contract.toObject(); const contents = [ descriptor, [this.identity.toString('hex'), this.contact] ]; ['end', 'error', 'destroy'].forEach((event) =&gt; { offerStream.on(event, () =&gt; this.offers.delete(routingKey)); }); this.offers.set(routingKey, offerStream); this.quasarPublish(topicString, contents, { routingKey }, (err) =&gt; { if (err) { return callback(err); } callback(null, offerStream); }); } /** * @callback Node~publishShardDescriptorCallback * @param {error|null} error * @param {Offers} offerStream - Readable stream of OFFER messages */ /** * Resolves the offer for the given shard hash and offer identifier * @param {string} hash - Shard hash for the contract * @param {string} offer - Unique offer identifier * @param {error|null} error - If applicable an error object * @param {object|null} contract - The resolved and signed contract * @param {Node~resolveContractOfferCallback} callback */ /* eslint max-params: [2, 5] */ resolveContractOffer(hash, offer, error, contract, callback) { const stream = this.offers.get(hash); const resolver = stream ? stream.resolvers.get(offer) : null; if (!resolver) { return callback(new Error('Offer resolver not found')); } resolver(error, contract); callback(null); } /** * @callback Node~resolveContractOfferCallback * @param {error|null} error */ /** * Subscribes to the supplied shard descriptor topics and executes the user * and exposes a stream of incoming shard descriptor messages * @param {string[]} descriptorCodes - See {@tutorial protocol} * @param {Node~subscribeShardDescriptorCallback} callback */ subscribeShardDescriptor(descriptorCodes, callback) { const descriptorStream = new ReadableStream({ read: () =&gt; null, objectMode: true }); descriptorCodes = descriptorCodes.map((code) =&gt; `0f${code}`); this.quasarSubscribe(descriptorCodes, ([descriptor, contact]) =&gt; { descriptor = Contract.from(descriptor); if (descriptor.isValid()) { descriptorStream.push([descriptor.toObject(), contact]); } }); callback(null, descriptorStream); } /** * @callback Node~subscribeShardDescriptorCallback * @param {error|null} error * @param {ReadableStream} descriptorStream - Readable stream of incoming * shard descriptors */ /** * Offers a peer an allocation for the storage of a given shard * descriptor-turned-contract, see {@tutorial storage-contracts} for details * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object} contract - The completed shard descriptor contract * @param {Node~offerShardAllocationCallback} callback */ offerShardAllocation(peer, descriptor, callback) { this.send('OFFER', [descriptor], peer, (err, result) =&gt; { if (err) { return callback(err); } const contract = Contract.from(result[0]); const hash = contract.get('data_hash'); const [, { xpub }] = peer; const key = `${hash}:${xpub}`; if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return callback(new Error( 'Peer replied with invalid or incomplete contract' )); } this.contracts.put(key, result[0], (err) =&gt; callback(err, contract)); }); } /** * @callback Node~offerShardAllocationCallback * @param {error|null} error * @param {object} contract - See {@tutorial storage-contracts} */ /** * Requests that the target peer update their local version of the given * contract. Used to extend storage time or terminate storage. Peer will * respond with an error or their updated, signed record of the renewal. * @param {array} peer * @param {string} peer.0 - Identity key string * @param {object} peer.1 - Address data for contact * @param {object} contract - The completed shard descriptor contract * @param {Node~requestContractRenewalCallback} callback */ requestContractRenewal(peer, descriptor, callback) { this.send('RENEW', [descriptor], peer, (err, result) =&gt; { if (err) { return callback(err); } const contract = Contract.from(result[0]); const hash = contract.get('data_hash'); const [, { xpub }] = peer; const key = `${hash}:${xpub}`; if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return callback(new Error( 'Peer replied with invalid or incomplete contract' )); } this.contracts.put(key, result, (err) =&gt; callback(err, contract)); }); } /** * @callback Node~requestContractRenewalCallback * @param {error|null} error * @param {object} contract - See {@tutorial storage-contracts} */ /** * Subscribes to capacity announcements for the given topic codes * and exposes announcements as a stream. * @param {string[]} descriptorCodes - See {@tutorial protocol} * @param {Node~subscribeCapacityAnnouncementCallback} callback */ subscribeCapacityAnnouncement(descriptorCodes, callback) { const capacityStream = new ReadableStream({ read: () =&gt; null, objectMode: true }); descriptorCodes = descriptorCodes.map((code) =&gt; `0c${code}`); this.quasarSubscribe(descriptorCodes, ([bytesAvailable, contact]) =&gt; { capacityStream.push([bytesAvailable, contact]); }); callback(null, capacityStream); } /** * @callback Node~subscribeCapacityAnnouncementCallback * @param {error|null} error * @param {ReadableStream} capacityStream */ /** * Announces to interested renter nodes that this node has capacity * available for renting. * @param {string[]} descriptorCode - See {@tutorial protocol} * @param {number} bytesAvailable - Total bytes capacity available * @param {Node~publishCapacityAnnouncementCallback} callback */ publishCapacityAnnouncement(descriptorCode, bytesAvailable, callback) { const contents = [ bytesAvailable, [this.identity.toString('hex'), this.contact] ]; this.claims = bytesAvailable &gt; 0 ? this.claims : []; this.quasarPublish(`0c${descriptorCode}`, contents, callback); } /** * @callback Node~publishCapacityAnnouncementCallback * @param {error|null} error */ /** * Claims capacity from a farming node, given a valid contract * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object} descriptor - Contract descriptor * @param {Node~claimFarmerCapacityCallback} callback */ claimFarmerCapacity(peer, descriptor, callback) { this.send('CLAIM', [descriptor], peer, callback); } /** * @callback Node~claimFarmerCapacityCallback * @param {error|null} error * @param {array} result * @param {object} result.0 - Completed contract result * @param {string} result.1 - Consignment token */ } module.exports = Node; × Search results Close "},"lib_offers.js.html":{"id":"lib_offers.js.html","title":"Source: lib/offers.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/offers.js 'use strict'; const { Readable: ReadableStream } = require('stream'); const merge = require('merge'); const { v4: uuid } = require('uuid'); /** * Manages a stream of offers for a given storage contract publication */ class Offers extends ReadableStream { static get DEFAULTS() { return { maxOffers: 12, farmerBlacklist: [] }; } /** * @constructor * @param {Contract} contract - Storage contract published to network * @param {Object} [options] * @param {Number} [options.maxOffers] - Maximum number of offers to process * @param {Array.&lt;String&gt;} [options.farmerBlacklist] - Reject offers from nodeID */ constructor(contract, options) { super({ objectMode: true }); this.options = merge(Offers.DEFAULTS, options); this.resolvers = new Map(); this._contract = contract; this._queue = []; this._offersQueued = 0; this._offersProccessed = 0; this._farmersDidOffer = []; this._isDestroyed = false; } /** * Triggered when an offer is received * @event Offers#data * @param {Object} data * @param {Contact} data.contact - The sending farmer for the offer * @param {Contract} data.contract - The received offer contract */ /** * Triggered when the maximum number of offers are received and processed * @event Offers#end */ /** * Triggered if an error occurs * @event Offers#error * @param {Error} error - The error object with message */ /** * Implements the underlying stream * @private */ _read() { if (this._offersProccessed === this.options.maxOffers) { return this.push(null); } const _push = () =&gt; { this._offersProccessed++; this.push(this._queue.shift()); } if (this._queue.length &gt; 0) { return setImmediate(_push); } this.once('_offerAddedToQueue', _push); } /** * Adds the offer to the internal queue if there is room * @param {array} contact - The sending farmer for the offer * @param {object} contract - The received offer contract * @param {function} callback */ queue(contact, contract, callback) { const self = this; const isDestroyed = this._isDestroyed; const farmerSentOffer = this._farmersDidOffer.indexOf(contact[0]) !== -1; const contractIncomplete = !contract.isComplete(); const maxReached = this._offersQueued === this.options.maxOffers; const id = uuid(); if (isDestroyed || farmerSentOffer || contractIncomplete || maxReached) { return callback(new Error('Storage offer rejected')); } this.resolvers.set(id, function() { callback(...arguments); self.resolvers.delete(id); }); this._farmersDidOffer.push(contact[0]); this._queue.push({ contact: contact, contract: contract.toObject(), id }); this._offersQueued++; this.emit('_offerAddedToQueue'); } /** * Tears down listeners and ends the stream */ destroy() { this._queue = []; this._isDestroyed = true; setImmediate(this.removeAllListeners.bind(this)); this.emit('destroy'); } } module.exports = Offers; × Search results Close "},"lib_proof.js.html":{"id":"lib_proof.js.html","title":"Source: lib/proof.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/proof.js 'use strict'; const { Transform: TransformStream } = require('stream'); const assert = require('assert'); const MerkleTree = require('mtree'); const crypto = require('crypto'); const utils = require('./utils'); /** * Provides interface for proving possession of a file for an * {@link AuditStream} */ class Proof extends TransformStream { /** * Verifies the proof given the merkle root and tree depth * @static * @memberof Proof * @param {*} proof - Compact proof result * @param {string} root - Merkle tree root from audit leaves * @param {number} depth - Depth of the merkle tree * @returns {string[]} */ static verify(proof, root, depth) { function _getChallengeResponse(tuple) { let data = tuple || proof; if (data.length === 1) { return utils.rmd160sha256(data[0], 'hex'); } if (Array.isArray(data[0])) { return _getChallengeResponse(data[0]); } else { return _getChallengeResponse(data[1]); } } function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); const proofhash = utils.rmd160sha256(proof[0], 'hex'); assert(Buffer.compare(proofhash, leaf) === 0, 'Invalid proof value'); return leaf; } let hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256(Buffer.concat([ Buffer.from(hashL, 'hex'), Buffer.from(hashR, 'hex') ])); } return [ _collapse(proof, _getChallengeResponse(), depth - 1), root ]; } /** * @constructor * @param {string[]} merkleLeaves - Bottom leaves of the audit merkle tree * @param {string|buffer} hexChallenge - The challenge data in hex to prepend * to shard */ constructor(leaves, challenge) { super({ objectMode: true }); assert(Array.isArray(leaves), 'Merkle leaves must be an array'); assert.ok(challenge, 'Invalid challenge supplied'); this._tree = new MerkleTree(this._generateLeaves(leaves), utils.rmd160sha256); if (!Buffer.isBuffer(challenge)) { this._challenge = Buffer.from(challenge, 'hex'); } else { this._challenge = challenge; } this._hasher = crypto.createHash('sha256').update(this._challenge); this._proof = null; } /** * Returns the generated proof structure * @return {array} */ getProofResult() { assert(Array.isArray(this._proof), 'Proof generation is not complete'); return this._proof; } /** * Handles writing the shard data to the proof stream * @private */ _transform(chunk, encoding, next) { this._hasher.update(chunk, encoding); next(); } /** * Generates the proof from the read data * @private */ _flush(done) { try { this._generateProof(); } catch (err) { return done(err); } this.push(this.getProofResult()); done(); } /** * Returns the index of the associated audit leaf * @private */ _findMatchIndex(leaves, leaf) { let challengenum = -1; for (let l = 0; l &lt; leaves.length; l++) { if (Buffer.compare(leaves[l], leaf) === 0) { challengenum = l; break; } } return challengenum; } /** * Calculate audit response * @private * @param {string} challenge - Challenge string sent by auditor * @returns {string[]} result - Challenge response */ _generateProof() { const response = utils.rmd160(this._hasher.digest()); const leaves = this._tree.level(this._tree.levels() - 1); const leaf = utils.rmd160sha256(response); let challengenum = this._findMatchIndex(leaves, leaf); let branches = [response.toString('hex')]; assert(challengenum !== -1, 'Failed to generate proof'); for (let i = (this._tree.levels() - 1); i &gt; 0; i--) { let level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1].toString('hex')]; } else { branches = [level[challengenum - 1].toString('hex'), branches]; } challengenum = Math.floor(challengenum / 2); } this._proof = branches; } /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {string[]} leaves */ _generateLeaves(leaves) { const numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; const emptyLeaves = []; for (let i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.map((i) =&gt; Buffer.from(i, 'hex')).concat(emptyLeaves); } } module.exports = Proof; × Search results Close "},"lib_rules.js.html":{"id":"lib_rules.js.html","title":"Source: lib/rules.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/rules.js 'use strict'; const { randomBytes } = require('crypto'); const async = require('async'); const utils = require('./utils'); const Contract = require('./contract'); const ProofStream = require('./proof'); /** * Represents Orc protocol handlers */ class Rules { /** * Constructs a Orc rules instance in the context of a Orc node * @constructor * @param {Node} node */ constructor(node) { this.node = node; } /** * Upon receipt of an OFFER message, nodes must validate the descriptor, * then ensure that the referenced shard is awaiting allocation(s). If both * checks succeed, then the descriptor is added to the appropriate offer * processing stream. Once the descriptor is processed, we respond back to * the originator with the final copy of the contract. * @param {object} request * @param {object} response */ offer(request, response, next) { const [descriptor] = request.params; const contract = Contract.from(descriptor); const shardKey = contract.get('data_hash'); const offerStream = this.node.offers.get(shardKey); if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return next(new Error('Invalid shard descriptor')); } if (!offerStream) { return next(new Error('Offers for descriptor are closed')); } offerStream.queue(request.contact, contract, (err, result) =&gt; { if (err) { return next(err); } response.send([result]); }); } /** * Upon receipt of a AUDIT message, the node must look up the contract that * is associated with each hash-challenge pair in the payload, prepend the * challenge to the shard data, and caclulate the resulting hash, formatted * as a compact proof. See {@tutorial compact-proofs}. * @param {object} request * @param {object} response */ audit(request, response, next) { const audits = request.params; const [, { xpub }] = request.contact; if (!Array.isArray(audits)) { return next(new Error('Invalid audit batch supplied')); } async.mapSeries(audits, ({ hash, challenge }, done) =&gt; { this.node.contracts.get(`${hash}:${xpub}`, (err, desc) =&gt; { if (err) { return done(null, { hash, proof: null }); } const contract = Contract.from(desc); const auditLeaves = contract.get('audit_leaves'); const proofStream = new ProofStream(auditLeaves, challenge); proofStream.on('error', () =&gt; { proofStream.removeAllListeners('finish'); done(null, { hash, proof: null }); }); proofStream.on('finish', () =&gt; { proofStream.removeAllListeners('error'); done(null, { hash, proof: proofStream.getProofResult() }); }); this.node.shards.createReadStream(hash, (err, shardStream) =&gt; { if (err) { return done(null, { hash, proof: null }); } shardStream.pipe(proofStream); }); }); }, (err, proofs) =&gt; response.send(proofs)); } /** * Upon receipt of a CONSIGN message, the node must verify that it has a * valid storage allocation and contract for the supplied hash and identity * of the originator. If so, it must generate an authorization token which * will be checked by the shard server before accepting the transfer of the * associated shard. * @param {object} request * @param {object} response */ consign(request, response, next) { const [hash] = request.params; const { contact } = request; this.node.contracts.get(`${hash}:${contact[1].xpub}`, (err, desc) =&gt; { if (err) { return next(err); } const now = Date.now(); const contract = Contract.from(desc); const token = randomBytes(32).toString('hex'); if (now &gt; contract.get('store_end')) { return next(new Error('Contract has expired')); } this.node.server.accept(token, hash, contact); response.send([token]); }); } /** * Upon receipt of a MIRROR message, the node must verify that it is in * possesion of the shard on behalf of the identity or the message * originator. If so, given the token-hash pair, it must attempt to upload * it's copy of the shard to the target to establish a mirror. * @param {object} request * @param {object} response */ mirror(request, response, next) { const [hash, token, target] = request.params; const { contact } = request; this.node.contracts.get(`${hash}:${contact[1].xpub}`, (err) =&gt; { if (err) { return next(err); } this.node.shards.createReadStream(hash, (err, shardStream) =&gt; { if (err) { return next(err); } const uploader = utils.createShardUploader(target, hash, token); uploader.on('response', (res) =&gt; { let result = ''; res.on('data', (data) =&gt; result += data.toString()); res.on('end', () =&gt; { if (res.statusCode !== 200) { return next(new Error(result)); } response.send([result]); }); }); shardStream.pipe(uploader).once('error', next); }); }); } /** * Upon receipt of a RETRIEVE message, the node must verify that it is in * possession of the shard on behalf of the identity of the originator. * If so, it must generate an authorization token which will be checked by * the shard server before accepting the transfer of the associated shard. * @param {object} request * @param {object} response */ retrieve(request, response, next) { const [hash] = request.params; const { contact } = request; this.node.contracts.get(`${hash}:${contact[1].xpub}`, (err) =&gt; { if (err) { return next(err); } const token = randomBytes(32).toString('hex'); this.node.shards.exists(hash, (err, exists) =&gt; { if (err || !exists) { return next(err || new Error('Shard not found')); } this.node.server.accept(token, hash, contact); response.send([token]); }); }); } /** * Upon receipt of a PROBE message, the node must attempt to send a PING * message to the originator using the declared contact information. If * successful, it must respond positively, otherwise error. * @param {object} request * @param {object} response */ probe(request, response, next) { this.node.ping(request.contact, (err) =&gt; { if (err) { return next(new Error('Failed to reach probe originator')); } response.send([]); }); } /** * Upon receipt of a RENEW message, the recipient farmer must extend or * terminate it's contract based on the new terms supplied by the renter. * If the renewal descriptor is valid and complete, the farmer must store * the updated version after signing and respond back to the originator * with the version containing the updated signature. * @param {object} request * @param {object} response */ renew(request, response, next) { const [descriptor] = request.params; const renewal = Contract.from(descriptor); const hash = renewal.get('data_hash'); const [, { xpub }] = request.contact; const key = `${hash}:${xpub}`; if (!(renewal.isValid() &amp;&amp; renewal.isComplete())) { return next(new Error('Descriptor is invalid or incomplete')); } this.node.contracts.get(key, (err, desc) =&gt; { if (err) { return next(err); } const allowed = [ 'renter_id', 'renter_hd_key', 'renter_signature', 'store_begin', 'store_end', 'audit_leaves' ]; const original = Contract.from(desc); const difference = Contract.diff(original, renewal); for (let prop of difference) { if (!allowed.includes(prop)) { return next(new Error(`Rejecting renewal of ${prop}`)); } } renewal.sign('farmer', this.node.spartacus.privateKey); this.node.contracts.put(key, renewal.toObject(), (err) =&gt; { if (err) { return next(err); } response.send([renewal.toObject()]); }); }); } /** * Upon receipt of an `CLAIM` message, nodes must validate the descriptor, * then ensure that there is enough available space for the shard. If both * checks succeed, then the descriptor is signed and returned along with a * consignment token so the initiating renter can immediately upload the * data. This call is the functional inverse of `OFFER`, as it is used for a * renter to signal to a farmer that it wishes to rent capacity. These * messages are generally sent based on information collected when subscribed * to farmer capacity publications. * @param {object} request * @param {object} response */ claim(request, response, next) { const [descriptor] = request.params; const contract = Contract.from(descriptor); const xpub = contract.get('renter_hd_key'); const hash = contract.get('data_hash'); if (!this.node.claims.includes(xpub) &amp;&amp; !this.node.claims.includes('*')) { return next(new Error('Currently rejecting claims')); } contract.set('farmer_id', this.node.identity.toString('hex')); contract.set('farmer_hd_key', this.node.contact.xpub); contract.set('farmer_hd_index', this.node.contact.index); contract.sign('farmer', this.node.spartacus.privateKey); if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return next(new Error('Invalid shard descriptor')); } this.node.contracts.put(`${hash}:${xpub}`, contract.toObject(), (err) =&gt; { if (err) { return next(err); } const token = randomBytes(32).toString('hex'); this.node.server.accept(token, hash, request.contact); response.send([contract.toObject(), token]); }); } } module.exports = Rules; × Search results Close "},"lib_server.js.html":{"id":"lib_server.js.html","title":"Source: lib/server.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/server.js 'use strict'; const merge = require('merge'); const async = require('async'); const assert = require('assert'); const { EventEmitter } = require('events'); const crypto = require('crypto'); const utils = require('./utils'); const Contract = require('./contract'); /** * Creates a shard server for sending and receiving consigned file shards */ class Server extends EventEmitter { static get DEFAULTS() { return { tokenTtl: 1800000 }; }; /** * @constructor * @license AGPL-3.0 * @param {object} options * @param {string} options.identity - Node identity key * @param {object} options.contracts - Contract database * @param {object} options.shards - KFS shard database * @param {number} [options.tokenTtl=1800000] - Expire unused token */ constructor(options) { super(); options = merge(Server.DEFAULTS, options); this.identity = options.identity; this.shards = options.shards; this.contracts = options.contracts; this._allowed = new Map(); this._ttl = options.tokenTtl; setInterval(() =&gt; this._reapExpiredTokens(), this._ttl); } /** * Triggered when a shard has finished uploading to this instance * @event Server#shardUploaded * @param {string} hash - The hash associated with the upload */ /** * Triggered when a shard has finished downloading from this instance * @event Server#shardDownloaded * @param {string} hash - The hash associated with the download */ /** * Triggered when a error occurs * @event Server#error * @param {error} error */ /** * Begin accepting data for the given file hash and token * @param {string} token - The authorization token created for transfer * @param {string} filehash - The shard hash to allow for the token * @param {array} contact - Contact that negotiated the token */ accept(token, filehash, contact) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed.set(token, { hash: filehash, contact: contact, expires: Date.now() + this._ttl }); } /** * Stop accepting data for the given token * @param {string} token - The authorization token created for transfer */ reject(token) { assert(typeof token === 'string', 'Invalid token supplied'); this._allowed.delete(token); } /** * Validates the given token * @param {string} token * @param {string} hash * @returns {object} */ authorize(token, hash) { assert.ok(token, 'You did not supply a token'); assert.ok(this._allowed.has(token), 'The token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(this._allowed.get(token).expires &gt; Date.now(), 'Token expired'); assert(this._allowed.get(token).hash === hash, 'Token not valid'); return this._allowed.get(token); } /** * Receives the data stream and writes it to storage * @param {http.IncomingMessage} req * @param {http.ServerResponse} req */ upload(req, res) { const hasher = crypto.createHash('sha256'); const { contact, hash } = merge({}, this._allowed.get(req.query.token)); function respond(err, statusCode) { res.statusCode = statusCode; res.end(err ? err.message : ''); } let shardSize = 0; let receivedBytes = 0; async.waterfall([ (next) =&gt; { try { this.authorize(req.query.token, req.params.hash); } catch (err) { return next(err, 401); } next(); }, (next) =&gt; { const contractKey = `${hash}:${contact[1].xpub}`; this.contracts.get(contractKey, (err, contract) =&gt; { if (err) { return next(err, 404); } contract = Contract.from(contract); shardSize = contract.get('data_size'); this.shards.createWriteStream(hash, (err, writeStream) =&gt; { if (err) { return next(err, 500); } next(null, writeStream, contract); }); }); }, (writeStream, contract, next) =&gt; { // TODO: Track transfer req.on('data', (chunk) =&gt; { receivedBytes += chunk.length; hasher.update(chunk); writeStream.write(chunk); if (receivedBytes &gt; shardSize) { this.shards.unlink(hash, () =&gt; null); next(new Error('Shard exceeds size defined in contract'), 400); } }); req.on('end', () =&gt; { if (utils.rmd160(hasher.digest()).toString('hex') !== hash) { this.shards.unlink(hash, () =&gt; null); return next(new Error('Hash does not match contract'), 400); } writeStream.end(); this.reject(req.query.token); this.emit('shardUploaded', contract); next(null, 200); }); } ], respond); } /** * Pumps the data through to the client * @param {http.IncomingMessage} req * @param {http.ServerResponse} res */ download(req, res) { function respond(err, statusCode) { res.statusCode = statusCode; res.end(err.message); } async.waterfall([ (next) =&gt; { try { this.authorize(req.query.token, req.params.hash); } catch (err) { return next(err, 401); } next(); }, (next) =&gt; { const { hash } = this._allowed.get(req.query.token); this.shards.createReadStream(hash, function(err, readStream) { if (err) { return next(err, 404); } next(null, readStream, hash); }); }, (readStream, hash) =&gt; { // TODO: Track transfer res.setHeader('content-type', 'application/octet-stream'); readStream .on('error', (/* err */) =&gt; res.end()) .on('end', () =&gt; { this.emit('shardDownloaded', hash); this.reject(req.query.token); }) .pipe(res); } ], respond); } /** * Enumerates the authorized list and rejects expired * @private */ _reapExpiredTokens() { let now = Date.now(); for (let [token] of this._allowed) { if (this._allowed.get(token).expires &lt; now) { this.reject(token); } } } } module.exports = Server; × Search results Close "},"lib_shards.js.html":{"id":"lib_shards.js.html","title":"Source: lib/shards.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/shards.js 'use strict'; const merge = require('merge'); const assert = require('assert'); const fs = require('fs'); const du = require('du'); const path = require('path'); /** * Convenience wrapper for storing shards scoped to a directory */ class Shards { static get DEFAULTS() { return { maxSpaceAllocated: 0 }; } /** * @constructor * @param {string} directory - Directory path to shard storage */ constructor(directory, options) { assert.ok(directory, 'Invalid directory supplied'); assert(fs.existsSync(directory), 'Supplied directory does not exist'); this.directory = directory; this.options = merge(Shards.DEFAULTS, options); } /** * Wraps read stream with error handling/callback * @param {string} key - The file key or hash * @param {Shards~createReadStreamCallback} callback */ createReadStream(key, callback) { let rs = null; try { rs = fs.createReadStream(path.join(this.directory, key)); } catch (err) { return callback(err); } callback(null, rs); } /** * @callback Shards~createReadStreamCallback * @param {error|null} error * @param {object} stream */ /** * Wraps write stream with error handling/callback * @param {string} key - The file key or hash * @param {Shards~createWriteStreamCallback} callback */ createWriteStream(key, callback) { let ws = null; try { ws = fs.createWriteStream(path.join(this.directory, key)); } catch (err) { return callback(err); } callback(null, ws); } /** * @callback Shards~createWriteStreamCallback * @param {error|null} error * @param {object} stream */ /** * Unlink the shard from the file system * @param {string} key * @param {Shards~unlinkCallback} callback */ unlink(key, callback) { fs.unlink(path.join(this.directory, key), callback); } /** * @callback Shards~unlinkCallback * @param {error|null} error */ /** * Check if the shard exists * @param {string} key * @param {Shards~existsCallback} callback */ exists(key, callback) { callback(null, fs.existsSync(path.join(this.directory, key))); } /** * @callback Shards~existsCallback * @param {error|null} error * @param {boolean} exists */ /** * Get used space and remaining allocation * @param {Shards~sizeCallback} callback */ size(callback) { du(this.directory, (err, used) =&gt; { if (err) { return callback(err); } const allocated = this.options.maxSpaceAllocated; callback(null, { allocated, available: used &gt;= allocated ? 0 : allocated - used }); }); } /** * @callback Shards~sizeCallback * @param {error|null} error * @param {object} size */ } module.exports = Shards; × Search results Close "},"lib_transport.js.html":{"id":"lib_transport.js.html","title":"Source: lib/transport.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Source: lib/transport.js 'use strict'; const url = require('url'); const merge = require('merge'); const connect = require('connect'); const { HTTPSTransport } = require('kad'); const { Agent } = require('https'); /** * Represents the Orc-specific HTTP(S) transport */ class Transport extends HTTPSTransport { /** * Emitted when a download request is received * @event Transport#download * @param {object} request * @param {object} response */ /** * Emitted when a upload request is received * @event Transport#upload * @param {object} request * @param {object} response */ /** * Contructs a Orc transport adapter * @constructor * @param {object} options * @see https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options */ constructor(options) { super(options); } /** * Make sure we explicity set the keepAlive options on requests * @private */ _createRequest(options) { const request = super._createRequest(merge({ agent: new Agent({ keepAlive: true, keepAliveMsecs: 25000 }), path: '/rpc/', rejectUnauthorized: false }, options)); request.setNoDelay(true); return request; } /** * Disable nagle algorithm on connections * @private */ _createServer(options) { const server = super._createServer(options); server.on('connection', (sock) =&gt; sock.setNoDelay(true)); return server; } /** * Handles requests by sending through middleware stack * @private */ _handle() { const middleware = connect(); middleware.use(Transport.CORS); middleware.use('/', (req, res, next) =&gt; { return req.url !== '/' ? next() : this.emit('identify', req, res); }); middleware.use('/rpc/', super._handle.bind(this)); middleware.use('/shards/', this._shards.bind(this)); middleware(...arguments); } /** * Handle routing request to shard server * @private */ _shards(req, res) { const urlobj = url.parse(req.originalUrl, true); const [, hash] = urlobj.pathname.split('/shards/'); req.query = urlobj.query; req.params = { hash }; if (req.method === 'POST') { this.emit('upload', req, res); } else if (req.method === 'GET') { this.emit('download', req, res); } else { res.statusCode = 405; res.end(); } } /** * Applies cross origin headers to responses * @static * @memberof Transport * @private */ static get CORS() { return function(req, res, next) { res.setHeader('access-control-allow-origin', '*'); res.setHeader('access-control-allow-methods', '*'); res.setHeader('access-control-allow-headers', '*'); if (req.method === 'OPTIONS') { res.statusCode = 200; res.end(); } else { next(); } } } } module.exports = Transport; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Modules Classes Audit Bridge Contract FarmerProfile Profile RenterProfile Node Offers Proof Rules Server Shards Transport Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Classes Classes Audit Bridge Contract FarmerProfile Profile RenterProfile Node Offers Proof Rules Server Shards Transport Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Tutorials Classes Audit Bridge Contract FarmerProfile Profile RenterProfile Node Offers Proof Rules Server Shards Transport Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification | | | The Onion Routed Cloud. Orc is a distributed anonymous cloud storage network owned and operated by all of us. Join us in #orcproject at The Open and Free Technology Community! Docker InstallationPull the image from Docker Hub. docker pull orcproject/orcCreate a data directory on the host. mkdir path/to/orc.dataRun the Orc container and mount the data directory. docker run -v path/to/orc.data:/root/.config/orc -t orcproject/orc:latestModify the created configuration at path/to/orc.data/config as desired (see the configuration docs) and restart the container for the changes to take effect. You might wish to expose the ports defined for ControlPort and BridgePort to the host (and update ControlHostname and BridgeHostname to 0.0.0.0) and map them to the host. docker run \\ --publish 127.0.0.1:4444:4444 \\ --publish 127.0.0.1:4445:4445 \\ --expose 4444 \\ --expose 4445 \\ --volume path/to/orc.data:/root/.config/orc \\ --tty orcproject/orc:latestSee the docker run documentation for more information. Manual InstallationMake sure you have the following prerequisites installed: Zcash Tor Git Node.js LTS + NPM (6.10.x) Python 2.7 GCC/G++/Make Node.js + NPMGNU+Linux &amp; Mac OSXwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bashClose your shell and open an new one. Now that you can call the nvm program, install Node.js (which comes with NPM): nvm install --ltsBuild DependenciesGNU+LinuxDebian / Ubuntu / Mint / Trisquel / and Friends apt install git python build-essentialRed Hat / Fedora / CentOS yum groupinstall 'Development Tools'You might also find yourself lacking a C++11 compiler - see this. Mac OSXxcode-select --installDaemon + Utilities CLIThis package exposes two command line programs: orc and orctool. To install these, use the --global flag. npm install -g @orcproject/orcCore LibraryThis package exposes a module providing a complete implementation of the protocol. To use it in your project, from your project's root directory, install as a dependency. npm install @orcproject/orc --saveUsageCommand LineSimply run orc with an optional configuration file using the --config &lt;path/to/config&gt; option. Spawning ChildThe easiest way to get up and running with orc is to spawn a child process from your program and connect to it over the control port. This package exposes a convenience method for doing this. const orc = require('@orcproject/orc'); const { child, controller } = orc(config); // The `config` argument can be either a string path to config file to use or // a JSON dictionary of config properties. See configuration documentaion. child.stdout.pipe(process.stdout); // Pipe log out put to stdout controller.on('ready', () =&gt; { controller.invoke('ping', [contact], console.log); // Ping a contact });Control InterfaceYou can run orc standalone and control it from any other application over its TCP control interface. See the Resources section below to read up on the control protocol to implement it in the language of your choice. If using Node.js, you can use the client bundled in this package. const orc = require('@orcproject/orc'); const controller = new orc.control.Client(); controller.on('ready', () =&gt; { controller.invoke('ping', [contact], (err) =&gt; { /* handle result */ }); }); controller.connect(port);If you wish to control your orc node from another language, simply connect to the control port over a TCP socket and use the BOSCAR protocol to send RPC messages to the node. The methods and argument signatures map directly to the orc.Node API describe in the documentation. See Resources below. Direct ImplementationSince orc exposes all of the internals used to implement it, you can use the same classes to directly implement your own Orc node within your project. Just import the package and construct a node instance with options. const orc = require('@orcproject/orc'); const node = new orc.Node(options); node.listen(8443); node.join(['known_node_id', { /* contact data */ }]);Consult the documentation for a complete reference of the API exposed from the Node object. Further documentation on usage can be found by reviewing the end-to-end test suite in test/node.e2e.js. Note that using this package as a library provides a very low level interface for the Orc protocol and is not intended for casual integration with the Orc network. Resources Orc Documentation Orc Protocol Specification LicenseOrc - Onion Routed CloudCopyright (C) 2017 Gordon HallCopyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close "},"Audit.html":{"id":"Audit.html","title":"Class: Audit","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Audit Audit Represents a streaming audit challenge generator new Audit(audits) Parameters: Name Type Description audits number Total number of challenges to generate Source: lib/audit.js Methods &lt;static&gt; fromRecords(challenges, tree) Returns a new instance from the predefined challenges and tree Parameters: Name Type Description challenges array The precomputed challenges tree array The bottom leaves of the existing merkle tree Source: lib/audit.js Returns: Type Audit getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/audit.js Returns: challenge - Private audit record with challenges Type Object getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/audit.js Returns: leaves - Bottom merkle leaves of audit tree Type Array × Search results Close "},"Bridge.html":{"id":"Bridge.html","title":"Class: Bridge","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Bridge Bridge Represents a local HTTP(s) server that abstracts the upload and download of files away to a simple request. Files are encrypted to the given public key, split into shards for erasure codes. Prepped for distribution and queued for storing in the network. Bridge exposes a simple API for getting status of transfers and previously stored objects. GET / (List objects as JSON) GET /{hash} (Download object) DELETE /{hash} (Delete object) POST / (Upload object - Multipart) new Bridge(node) Parameters: Name Type Description node Node Source: lib/bridge.js Methods audit(callback) Periodically call this to scan the object store for shards that need to be audited, perform audit, and issue payment Parameters: Name Type Description callback function Source: lib/bridge.js authenticate(request, response, next) Handles request authentication if defined Parameters: Name Type Description request object response object next function Source: lib/bridge.js createRequestHandler() Creates request router and handler stack Source: lib/bridge.js Returns: Type function destroy(request, response, next) Ends contracts with farmers for the object parts and removes reference to them Parameters: Name Type Description request object response object next function Source: lib/bridge.js distribute(filepath, metadata) Takes the supplied file path and applies erasure codes, then attempts to distribute the shards across the network Parameters: Name Type Description filepath string Path to the file to distribute metadata object Properties Name Type Description encoding string mimetype string hash string Source: lib/bridge.js Returns: Type EventEmitter download(request, response, next) Downloads the object from the network Parameters: Name Type Description request object response object next function Source: lib/bridge.js error(error, request, response, next) Responds to requests with error code and message Parameters: Name Type Description error error request object response object next function Source: lib/bridge.js list(request, response, next) Scans the object database and returns all index entries Parameters: Name Type Description request object response object next function Source: lib/bridge.js listen(port, hostname, callback) Listens on the given port and hostname Parameters: Name Type Description port number hostname string callback function Source: lib/bridge.js route(request, response, next) Handles routing requests to their appropriate handler Parameters: Name Type Description request object response object next function Source: lib/bridge.js upload(request, response, next) Queues the object for upload to the network Parameters: Name Type Description request object response object next function Source: lib/bridge.js × Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Contract Contract Represents a storage contract between a renter and a farmer new Contract(contract, criteria) Parameters: Name Type Description contract object Properties Name Type Argument Description type string Unique identifier for the contract renter_hd_key string &lt;optional&gt; Node extended public key in base58 renter_hd_index number &lt;optional&gt; Derivation index for signature renter_id string Node ID of the renter renter_signature string Renter's cryptographic signature farmer_hd_key string &lt;optional&gt; Node extended public key in base58 farmer_hd_index number &lt;optional&gt; Derivation index for signature farmer_id string Node ID of the farmer farmer_signature string Farmer's cryptographic signature data_size number Number of bytes to store data_hash string RIPEMD-160 SHA-256 hash of the data store_begin number UNIX timestamp to start contract store_end number UNIX timestamp to end the contract audit_count number Number of audits renter will perform audit_leaves Array.&lt;string&gt; Merkle leaves for audit tree payment_storage_price number Total price for storage payment_download_price number Price per download payment_destination string Zcash address to send funds criteria object Properties Name Type Description size number Criteria degree OPCODE duration number Criteria degree OPCODE availability number Criteria degree OPCODE speed number Criteria degree OPCODE Source: lib/contract.js Members &lt;static&gt; CRITERIA Defines some default criteria of a Contract Source: lib/contract.js &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract.js &lt;static&gt; MATRIX Defines the criteria matrix for a Contract Source: lib/contract.js &lt;static&gt; schema Defines the JSON Schema of a Contract Source: lib/contract.js &lt;static&gt; validator Validation function against the schema Source: lib/contract.js Methods &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract.js Returns: Type boolean &lt;static&gt; createTopic(criteria) Create a topical OPCODE byte sequence from the provided criteria Parameters: Name Type Description criteria object Properties Name Type Description size number Criteria degree OPCODE duration number Criteria degree OPCODE availability number Criteria degree OPCODE speed number Criteria degree OPCODE Source: lib/contract.js Returns: Type buffer &lt;static&gt; diff(c1, c2) Returns the property names between two contracts that differ Parameters: Name Type Description c1 Contract Contract to compare c2 contract Contract to compare Source: lib/contract.js Returns: changedProperties Type Array.&lt;string&gt; &lt;static&gt; from(data) Infers the type of object supplied and constructs a contract Parameters: Name Type Description data object | string | buffer Source: lib/contract.js Returns: Type Contract &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer buffer Raw binary blob of contract data Source: lib/contract.js Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json string JSON encoded contract Source: lib/contract.js Returns: Type Contract &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object object Dictionary of contract data Source: lib/contract.js Returns: Type Contract get(field) Returns the value for the given contract property Parameters: Name Type Description field string Contract property to get Source: lib/contract.js Returns: value Type string | number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract.js Returns: Type buffer getSigningData() Returns the string representation of the contract, minus the signature fields, sorted alphanumerically for signing and verifying Source: lib/contract.js Returns: Type string getTopicBuffer() Return OPCODE byte sequence for contract publication topic Source: lib/contract.js Returns: Type buffer getTopicString() Return OPCODE byte sequence for contract publication topic as hex string Source: lib/contract.js Returns: Type string isComplete() Checks if the contract is complete Source: lib/contract.js Returns: completed Type boolean set(field, value) Sets the contract property to the given value Parameters: Name Type Description field string Contract property to set value string | number Value to set for field Source: lib/contract.js Returns: Type string | number | null sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor string One of 'farmer' or 'renter' secret buffer ECDSA private key Source: lib/contract.js Returns: signature Type string signExternal(secret) Signs the contract with the proved key and returns the signature Parameters: Name Type Description secret buffer ECDSA private key Source: lib/contract.js Returns: Type buffer toBuffer() Converts the contract to Buffer Source: lib/contract.js Returns: Type buffer toJSON() Converts the contract to JSON string Source: lib/contract.js Returns: Type string toObject() Converts the contract to a plain object Source: lib/contract.js Returns: Type object update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields object Contract properties to update Source: lib/contract.js Returns: Type Contract verify(actor) Verify the contract signature for the given actor Parameters: Name Type Description actor string One of 'farmer' or 'renter' Source: lib/contract.js Returns: Type boolean verifyExternal(signature, pubkey) Verify the provided signature for the contract Parameters: Name Type Description signature buffer The contract signature to verify pubkey buffer ECDSA public key Source: lib/contract.js Returns: Type boolean × Search results Close "},"module-orc.html":{"id":"module-orc.html","title":"Module: orc","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Module: orc (require(&quot;orc&quot;))(config) Forks a child orc process and returns the child process and a controller client for sending commands to it Parameters: Name Type Description config object | string Configuration properties as object or path to a configuration file. See Node Configuration &amp; Setup for details. connect to the control port Source: index.js Returns: Type object Members &lt;static&gt; Audit Audit Source: index.js &lt;static&gt; Bridge Bridge Source: index.js &lt;static&gt; constants module:orc/constants Source: index.js &lt;static&gt; Contract Contract Source: index.js &lt;static&gt; control Source: index.js See: https://github.com/bookchin/boscar &lt;static&gt; Node Node Source: index.js &lt;static&gt; Offers Offers Source: index.js &lt;static&gt; profiles module:orc/profiles Source: index.js &lt;static&gt; Proof Proof Source: index.js &lt;static&gt; Rules Rules Source: index.js &lt;static&gt; Server Server Source: index.js &lt;static&gt; Shards Shards Source: index.js &lt;static&gt; Transport Transport Source: index.js &lt;static&gt; utils module:orc/utils Source: index.js &lt;static&gt; version module:orc/version Source: index.js × Search results Close "},"module-orc_constants.html":{"id":"module-orc_constants.html","title":"Module: orc/constants","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Module: orc/constants Source: lib/constants.js Members &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js &lt;inner, constant&gt; CLEAN_INTERVAL :Number Interval for reaping stale shards Type: Number Source: lib/constants.js &lt;inner, constant&gt; CONSIGN_THRESHOLD :Number Threshold for consign time Type: Number Source: lib/constants.js &lt;inner, constant&gt; HD_KEY_DERIVATION_PATH Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_AUDITS :Number Number of concurrent audits Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_OFFERS :Number Number of concurrent offers Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_NODE_INDEX Source: lib/constants.js &lt;inner, constant&gt; OFFER_TIMEOUT :Number Max wait time for storage offer Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_CONTRACT_PREFIX :Number Prefix opcode for contracts Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_HIGH :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_LOW :Number Opcode for low criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_MED :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_NULL :Number Opcode for null criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; TOKEN_EXPIRE :Number Reject datachannl token after time Type: Number Source: lib/constants.js × Search results Close "},"module-orc_profiles.html":{"id":"module-orc_profiles.html","title":"Module: orc/profiles","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Module: orc/profiles Source: lib/profiles.js Classes FarmerProfile Profile RenterProfile Methods &lt;static&gt; farmer(node, config) Applies the farmer profile Parameters: Name Type Description node Node config object Source: lib/profiles.js Returns: Type FarmerProfile &lt;static&gt; renter(node, config) Applies the renter profile Parameters: Name Type Description node Node config object Source: lib/profiles.js Returns: Type RenterProfile × Search results Close "},"module-orc_profiles-FarmerProfile.html":{"id":"module-orc_profiles-FarmerProfile.html","title":"Class: FarmerProfile","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: FarmerProfile orc/profiles~ FarmerProfile Applies the farmer profile to the supplied node. A farmer publishes capacity announcements, subscribes to contract publications, and reaps stale shards. new FarmerProfile(node, config) Parameters: Name Type Description node Node config object Source: lib/profiles.js Methods announceCapacity(callback) Announces current storage capacity to neighbors Parameters: Name Type Description callback FarmerProfile~announceCapacityCallback Source: lib/profiles.js reapExpiredShards(callback) Scans the contract database for expired shards and reaps them from storage Parameters: Name Type Description callback FarmerProfile~reapExpiredShardsCallback Source: lib/profiles.js × Search results Close "},"module-orc_profiles-Profile.html":{"id":"module-orc_profiles-Profile.html","title":"Class: Profile","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Profile orc/profiles~ Profile Base class for a profile, sets up zcash wallet and other shared profile behavior new Profile(node, config) Parameters: Name Type Description node Node config object Source: lib/profiles.js Methods getNewAddress(callback) Generates a new zcash address Parameters: Name Type Description callback Profile~getNewAddressCallback Source: lib/profiles.js × Search results Close "},"module-orc_profiles-RenterProfile.html":{"id":"module-orc_profiles-RenterProfile.html","title":"Class: RenterProfile","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: RenterProfile orc/profiles~ RenterProfile Applies the renter profile to the supplied node. A renter listens for capacity announcements and keeps a cache, exposes a local bridge for upload/download, handles auditing, mirroring, and payments. new RenterProfile(node, config) Parameters: Name Type Description node Node config object Source: lib/profiles.js Methods getCapacityCache(callback) Exposes the capacity cache over the control port Parameters: Name Type Description callback RenterProfile~getCapacityCacheCallback Source: lib/profiles.js × Search results Close "},"module-orc_utils.html":{"id":"module-orc_utils.html","title":"Module: orc/utils","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Module: orc/utils Source: lib/utils.js Methods &lt;static&gt; createCipher(publicKey, privateKey) Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret derived from the given public and private keys Parameters: Name Type Description publicKey buffer SECP256k1 public key bytes privateKey buffer SECP256k1 private key bytes Source: lib/utils.js Returns: Type object &lt;static&gt; createComplexKeyFromSeed(seed64) Returns a HD key object using corrent key derivation path using the given seed Parameters: Name Type Description seed64 buffer 64 byte seed for generating key Source: lib/utils.js Returns: Type HDKey &lt;static&gt; createDecipher(publicKey, privateKey) Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret derived from the given public and private keys Parameters: Name Type Description publicKey buffer SECP256k1 public key bytes privateKey buffer SECP256k1 private key bytes Source: lib/utils.js Returns: Type object &lt;static&gt; createShardDownloader(farmer, hash, token) Returns a request object for downloading a shard from a farmer Parameters: Name Type Description farmer array Farmer contact object hash string The hash of the shard to upload token string The authorized transfer token Source: lib/utils.js Returns: Type https.ClientRequest &lt;static&gt; createShardUploader(farmer, hash, token) Returns a request object for uploading a shard to a farmer Parameters: Name Type Description farmer array Farmer contact object hash string The hash of the shard to upload token string The authorized transfer token Source: lib/utils.js Returns: Type https.ClientRequest &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact array Properties Name Type Description 0 string Node identity key 1 object Properties Name Type Description hostname string port string protocol string Source: lib/utils.js Returns: Type string &lt;static&gt; getErasureParameters(n) Returns the appropriate shard size, number of shards, and number of parity shards for RS encoding/decoding provided the total number of bytes of the complete content Parameters: Name Type Description n number Number of bytes in data Source: lib/utils.js Returns: Type object &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number number Source: lib/utils.js Returns: Type number &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version string The semver tag from the contact Source: lib/utils.js Returns: Type boolean &lt;static&gt; isHexaString(a) Determines if a value is hexadecimal string Parameters: Name Type Description a * The value to be tested Source: lib/utils.js Returns: Type boolean &lt;static&gt; isValidContact(contact, loopback) Determines if the supplied contact is valid Parameters: Name Type Description contact array The contact information for a given peer loopback boolean Allows contacts that are localhost Source: lib/utils.js Returns: Type boolean &lt;static&gt; isValidHDNodeKey(hdKey) Checks if the supplied HD key is valid (base58 encoded) and proper length Parameters: Name Type Description hdKey string The HD key in base 58 encoding Source: lib/utils.js Returns: isValidHDKey Type boolean &lt;static&gt; isValidNodeIndex(hdIndex) Checks if the input is a non-hardened HD key index Parameters: Name Type Description hdIndex number The HD key index Source: lib/utils.js Returns: isValidHDKeyIndex Type boolean &lt;static&gt; rmd160(input, encoding) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: lib/utils.js Returns: Type buffer &lt;static&gt; rmd160sha256(input, encoding) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: lib/utils.js Returns: Type buffer &lt;static&gt; sha256(input, encoding) Returns the SHA-256 hash of the input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: lib/utils.js Returns: Type buffer × Search results Close "},"module-orc_version.html":{"id":"module-orc_version.html","title":"Module: orc/version","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Module: orc/version Source: lib/version.js Members &lt;inner, constant&gt; protocol :string The supported protocol version Type: string Source: lib/version.js &lt;inner, constant&gt; software :string The current software version Type: string Source: lib/version.js Methods &lt;static&gt; toString() Returns human readable string of versions Source: lib/version.js Returns: Type string × Search results Close "},"Node.html":{"id":"Node.html","title":"Class: Node","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Node Node Extends Kademlia with Orc protocol rules new Node(options) Parameters: Name Type Description options object Properties Name Type Argument Description privateExtendedKey string HD extended private key logger object &lt;optional&gt; Bunyan compatible logger transport object &lt;optional&gt; Orc transport adapter contracts object Levelup compatible contract store shards object KFS compatible shard database claims Array.&lt;string&gt; &lt;optional&gt; Enable direct capacity claims from the given public extended keys keyDerivationIndex number &lt;optional&gt; HD derivation index License: AGPL-3.0 Source: lib/node.js Methods auditRemoteShards(peer, audits, callback) Sends the series of hash/challenge pairs to the remote node to request proof-of-storage Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact audits Array.&lt;object&gt; Properties Name Type Description hash string Hash of the shard to prove challenge string Challenge string to prepend to shard callback Node~auditRemoteShardsCallback Source: lib/node.js authorizeConsignment(peer, hashes, callback) Requests authorization tokens to push file shard(s) to another node Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hashes Array.&lt;string&gt; Hashes of the shards to push callback Node~authorizeConsignmentCallback Source: lib/node.js authorizeRetrieval(peer, hashes, callback) Requests authorization tokens to pull file shard(s) from another node Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hashes Array.&lt;string&gt; Hashes of the shards to pull callback Node~authorizeRetrievalCallback Source: lib/node.js claimFarmerCapacity(peer, descriptor, callback) Claims capacity from a farming node, given a valid contract Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact descriptor object Contract descriptor callback Node~claimFarmerCapacityCallback Source: lib/node.js createShardMirror(source, target, callback) Requests the source node to MIRROR a shard to the supplied destination Parameters: Name Type Description source array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact target object Properties Name Type Description destination array - Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hash string Hash of the shard to mirror token string Authorization token to PUSH shard callback Node~createShardMirrorCallback Source: lib/node.js identifyService(url, callback) Sends a GET request to the URI and parses the result as a valid contact object with identity Parameters: Name Type Description url string The URL of the node callback Node~identifyServiceCallback Source: lib/node.js listen() Adds the kademlia rule handlers before calling super#listen() Source: lib/node.js offerShardAllocation(peer, contract, callback) Offers a peer an allocation for the storage of a given shard descriptor-turned-contract, see storage-contracts for details Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact contract object The completed shard descriptor contract callback Node~offerShardAllocationCallback Source: lib/node.js publishCapacityAnnouncement(descriptorCode, bytesAvailable, callback) Announces to interested renter nodes that this node has capacity available for renting. Parameters: Name Type Description descriptorCode Array.&lt;string&gt; See Protocol Specification bytesAvailable number Total bytes capacity available callback Node~publishCapacityAnnouncementCallback Source: lib/node.js publishShardDescriptor(contract [, offerStreamOptions], callback) Publishes a storage contract proposal to the network and exposes a stream of received OFFER messages Parameters: Name Type Argument Description contract object See storage-contracts for format offerStreamOptions object &lt;optional&gt; See OfferStream callback Node~publishShardDescriptorCallback Source: lib/node.js requestContractRenewal(peer, contract, callback) Requests that the target peer update their local version of the given contract. Used to extend storage time or terminate storage. Peer will respond with an error or their updated, signed record of the renewal. Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 object Address data for contact contract object The completed shard descriptor contract callback Node~requestContractRenewalCallback Source: lib/node.js resolveContractOffer(hash, offer, error, contract, callback) Resolves the offer for the given shard hash and offer identifier Parameters: Name Type Description hash string Shard hash for the contract offer string Unique offer identifier error error | null If applicable an error object contract object | null The resolved and signed contract callback Node~resolveContractOfferCallback Source: lib/node.js subscribeCapacityAnnouncement(descriptorCodes, callback) Subscribes to capacity announcements for the given topic codes and exposes announcements as a stream. Parameters: Name Type Description descriptorCodes Array.&lt;string&gt; See Protocol Specification callback Node~subscribeCapacityAnnouncementCallback Source: lib/node.js subscribeShardDescriptor(descriptorCodes, callback) Subscribes to the supplied shard descriptor topics and executes the user and exposes a stream of incoming shard descriptor messages Parameters: Name Type Description descriptorCodes Array.&lt;string&gt; See Protocol Specification callback Node~subscribeShardDescriptorCallback Source: lib/node.js Type Definitions auditRemoteShardsCallback(error, proofs) Parameters: Name Type Description error object | null proofs Array.&lt;object&gt; Properties Name Type Description hash string Hash of the shard for corresponding proof proof string compact-merkle-proof Source: lib/node.js authorizeConsignmentCallback(error, consignmentTokens) Parameters: Name Type Description error error | null consignmentTokens Array.&lt;string&gt; Source: lib/node.js authorizeRetrievalCallback(error, retrievalTokens) Parameters: Name Type Description error error | null retrievalTokens Array.&lt;string&gt; Source: lib/node.js claimFarmerCapacityCallback(error, result) Parameters: Name Type Description error error | null result array Properties Name Type Description 0 object Completed contract result 1 string Consignment token Source: lib/node.js createShardMirrorCallback(error) Parameters: Name Type Description error object | null Source: lib/node.js identifyServiceCallback(error, contact) Parameters: Name Type Description error error | null contact array Source: lib/node.js offerShardAllocationCallback(error, contract) Parameters: Name Type Description error error | null contract object See storage-contracts Source: lib/node.js publishCapacityAnnouncementCallback(error) Parameters: Name Type Description error error | null Source: lib/node.js publishShardDescriptorCallback(error, offerStream) Parameters: Name Type Description error error | null offerStream Offers Readable stream of OFFER messages Source: lib/node.js requestContractRenewalCallback(error, contract) Parameters: Name Type Description error error | null contract object See storage-contracts Source: lib/node.js resolveContractOfferCallback(error) Parameters: Name Type Description error error | null Source: lib/node.js subscribeCapacityAnnouncementCallback(error, capacityStream) Parameters: Name Type Description error error | null capacityStream ReadableStream Source: lib/node.js subscribeShardDescriptorCallback(error, descriptorStream) Parameters: Name Type Description error error | null descriptorStream ReadableStream Readable stream of incoming shard descriptors Source: lib/node.js × Search results Close "},"Offers.html":{"id":"Offers.html","title":"Class: Offers","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Offers Offers Manages a stream of offers for a given storage contract publication new Offers(contract [, options]) Parameters: Name Type Argument Description contract Contract Storage contract published to network options Object &lt;optional&gt; Properties Name Type Argument Description maxOffers Number &lt;optional&gt; Maximum number of offers to process farmerBlacklist Array.&lt;String&gt; &lt;optional&gt; Reject offers from nodeID Source: lib/offers.js Methods destroy() Tears down listeners and ends the stream Source: lib/offers.js queue(contact, contract, callback) Adds the offer to the internal queue if there is room Parameters: Name Type Description contact array The sending farmer for the offer contract object The received offer contract callback function Source: lib/offers.js Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js × Search results Close "},"Proof.html":{"id":"Proof.html","title":"Class: Proof","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Proof Proof Provides interface for proving possession of a file for an AuditStream new Proof(merkleLeaves, hexChallenge) Parameters: Name Type Description merkleLeaves Array.&lt;string&gt; Bottom leaves of the audit merkle tree hexChallenge string | buffer The challenge data in hex to prepend to shard Source: lib/proof.js Methods &lt;static&gt; verify(proof, root, depth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description proof * Compact proof result root string Merkle tree root from audit leaves depth number Depth of the merkle tree Source: lib/proof.js Returns: Type Array.&lt;string&gt; getProofResult() Returns the generated proof structure Source: lib/proof.js Returns: Type array × Search results Close "},"Rules.html":{"id":"Rules.html","title":"Class: Rules","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Rules Rules Represents Orc protocol handlers new Rules(node) Constructs a Orc rules instance in the context of a Orc node Parameters: Name Type Description node Node Source: lib/rules.js Methods audit(request, response) Upon receipt of a AUDIT message, the node must look up the contract that is associated with each hash-challenge pair in the payload, prepend the challenge to the shard data, and caclulate the resulting hash, formatted as a compact proof. See compact-proofs. Parameters: Name Type Description request object response object Source: lib/rules.js claim(request, response) Upon receipt of an `CLAIM` message, nodes must validate the descriptor, then ensure that there is enough available space for the shard. If both checks succeed, then the descriptor is signed and returned along with a consignment token so the initiating renter can immediately upload the data. This call is the functional inverse of `OFFER`, as it is used for a renter to signal to a farmer that it wishes to rent capacity. These messages are generally sent based on information collected when subscribed to farmer capacity publications. Parameters: Name Type Description request object response object Source: lib/rules.js consign(request, response) Upon receipt of a CONSIGN message, the node must verify that it has a valid storage allocation and contract for the supplied hash and identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: Name Type Description request object response object Source: lib/rules.js mirror(request, response) Upon receipt of a MIRROR message, the node must verify that it is in possesion of the shard on behalf of the identity or the message originator. If so, given the token-hash pair, it must attempt to upload it's copy of the shard to the target to establish a mirror. Parameters: Name Type Description request object response object Source: lib/rules.js offer(request, response) Upon receipt of an OFFER message, nodes must validate the descriptor, then ensure that the referenced shard is awaiting allocation(s). If both checks succeed, then the descriptor is added to the appropriate offer processing stream. Once the descriptor is processed, we respond back to the originator with the final copy of the contract. Parameters: Name Type Description request object response object Source: lib/rules.js probe(request, response) Upon receipt of a PROBE message, the node must attempt to send a PING message to the originator using the declared contact information. If successful, it must respond positively, otherwise error. Parameters: Name Type Description request object response object Source: lib/rules.js renew(request, response) Upon receipt of a RENEW message, the recipient farmer must extend or terminate it's contract based on the new terms supplied by the renter. If the renewal descriptor is valid and complete, the farmer must store the updated version after signing and respond back to the originator with the version containing the updated signature. Parameters: Name Type Description request object response object Source: lib/rules.js retrieve(request, response) Upon receipt of a RETRIEVE message, the node must verify that it is in possession of the shard on behalf of the identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: Name Type Description request object response object Source: lib/rules.js × Search results Close "},"Server.html":{"id":"Server.html","title":"Class: Server","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Server Server Creates a shard server for sending and receiving consigned file shards new Server(options) Parameters: Name Type Description options object Properties Name Type Argument Default Description identity string Node identity key contracts object Contract database shards object KFS shard database tokenTtl number &lt;optional&gt; 1800000 Expire unused token Source: lib/server.js Methods accept(token, filehash, contact) Begin accepting data for the given file hash and token Parameters: Name Type Description token string The authorization token created for transfer filehash string The shard hash to allow for the token contact array Contact that negotiated the token Source: lib/server.js authorize(token, hash) Validates the given token Parameters: Name Type Description token string hash string Source: lib/server.js Returns: Type object download(req, res) Pumps the data through to the client Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: lib/server.js reject(token) Stop accepting data for the given token Parameters: Name Type Description token string The authorization token created for transfer Source: lib/server.js upload(req, req) Receives the data stream and writes it to storage Parameters: Name Type Description req http.IncomingMessage req http.ServerResponse Source: lib/server.js Events error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js × Search results Close "},"Shards.html":{"id":"Shards.html","title":"Class: Shards","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Shards Shards Convenience wrapper for storing shards scoped to a directory new Shards(directory) Parameters: Name Type Description directory string Directory path to shard storage Source: lib/shards.js Methods createReadStream(key, callback) Wraps read stream with error handling/callback Parameters: Name Type Description key string The file key or hash callback Shards~createReadStreamCallback Source: lib/shards.js createWriteStream(key, callback) Wraps write stream with error handling/callback Parameters: Name Type Description key string The file key or hash callback Shards~createWriteStreamCallback Source: lib/shards.js exists(key, callback) Check if the shard exists Parameters: Name Type Description key string callback Shards~existsCallback Source: lib/shards.js size(callback) Get used space and remaining allocation Parameters: Name Type Description callback Shards~sizeCallback Source: lib/shards.js unlink(key, callback) Unlink the shard from the file system Parameters: Name Type Description key string callback Shards~unlinkCallback Source: lib/shards.js Type Definitions createReadStreamCallback(error, stream) Parameters: Name Type Description error error | null stream object Source: lib/shards.js createWriteStreamCallback(error, stream) Parameters: Name Type Description error error | null stream object Source: lib/shards.js existsCallback(error, exists) Parameters: Name Type Description error error | null exists boolean Source: lib/shards.js sizeCallback(error, size) Parameters: Name Type Description error error | null size object Source: lib/shards.js unlinkCallback(error) Parameters: Name Type Description error error | null Source: lib/shards.js × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Class: Transport Transport Represents the Orc-specific HTTP(S) transport new Transport(options) Contructs a Orc transport adapter Parameters: Name Type Description options object Source: lib/transport.js Events download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"tutorial-config.html":{"id":"tutorial-config.html","title":"Tutorial: Node Configuration & Setup","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Node Configuration &amp; Setup This guide will show you how to get started with running orc! An Orc node requires a configuration file to get up and running. The path to this file is given to orc when starting a node. orc --config path/to/orc.configIf a configuration file is not supplied, a minimal default configuration is automatically created and used, which will generate a private extended key, self-signed SSL certificate, and storage for shards, contracts, and directory information. All of this data will be created and stored in $HOME/.config/orc, yielding a directory structure like this: +- ~/.config/orc + - x_private_key + - onion_key + - config + - service_key.pem + - certificate.pem + - /contracts.db + - ... + - /shards.kfs + - ... + - /directory.db + - ...The locations of all of these files is defined in your configuration file. Below is a complete sample config in INI format (though JSON is also supported). Comments are inline to describe each property. Default Configuration; ; Orc Sample Configuration ; ; Path to private extended key file to use for master identity. ; Generate one with: ; ; orctool generate-key --extended &gt;&gt; x_private_key ; PrivateExtendedKeyPath = /home/bookchin/.config/orc/x_private_key ; The index for deriving this child node's identity. This allows you to run ; multiple nodes with the same private extended key. If your private extended ; key was converted from an old non-hierarchically-deterministic private key, ; you must set the value to -1 ChildDerivationIndex = 0 ; Set the base directory (parent) for where the contracts.db folder will be ; placed. The contracts.db holds storage contracts between you and other nodes. ContractStorageBaseDir = /home/bookchin/.config/orc ; Set the base directory (parent) for where the shards.kfs folder will be ; placed. The shards.kfs stores other nodes data shards, so be sure you set ; this to where you intend to store farmed shards. ShardStorageBaseDir = /home/bookchin/.config/orc ; Define the maximum size you wish to allocate for farming shards. This can be ; increased later, but decreasing it will not delete existing data. ShardStorageMaxAllocation = 0GB ; Enables renter nodes to directly claim storage capacity based on any capacity ; announcements you have made. If you are farming, set this value once for every ; trusted renter public extended key from which you will accept claims or once ; with a value of * AllowDirectStorageClaims[] = * ; Set the base directory (parent) for where the directory.db folder will be ; placed. The directory.db holds key-value pairs for the distributed hash ; table, which serve various purposes such as reputation data on other peers. DirectoryStorageBaseDir = /home/bookchin/.config/orc ; Paths to this node's SSL key and certificat. If you don't have one, you can ; generate one with the following: ; ; orctool generate-cert | csplit - 28 ; mv xx00 service_key.pem ; mv xx01 certificate.pem ; TransportServiceKeyPath = /home/bookchin/.config/orc/service_key.pem TransportCertificatePath = /home/bookchin/.config/orc/certificate.pem ; Path to this node's RSA1024 Tor hidden service private key. If this path does ; not exist, it will be automatically generated for you. If you'd like to ; generate one yourself, you can use: ; ; orctool generate-onion &gt;&gt; onion_key ; OnionServicePrivateKeyPath = /home/bookchin/.config/orc/onion_key ; Set the public port number at which your node will be reachable to others. ; This should be the port you forwarded. PublicPort = 443 ; Set the local port to bind the node service. ListenPort = 4443 ; Enables bandwidth metering and hibernation mode. When the property ; BandwidthAccountingEnabled is 1, we will enter low-bandwidth mode if the we ; exceed BandwidthAccountingMax within the period defined by the property ; BandwidthAccountingReset until the interval is finished BandwidthAccountingEnabled = 0 BandwidthAccountingMax = 5GB BandwidthAccountingReset = 24HR ; Set to 1 for more detailed logging, which is useful for debugging VerboseLoggingEnabled = 1 ; Set the ControlPort to bind the control interface. Used for controlling the ; node from other applications. Be sure that ControlHostname is kept set to ; a loopback address, unless you have taken other measures to prevent others ; from controlling your node. ControlPort = 4444 ControlHostname = 127.0.0.1 ; Add a map of network bootstrap nodes to this section to use for discovering ; other peers. Default configuration should come with a list of known and ; trusted contacts. Formatted as &quot;https://{onion}:{port}&quot;. NetworkBootstrapNodes[] = https://orcjd7xgshpovm6i.onion:443 NetworkBootstrapNodes[] = https://orcjfg52ty6ljv54.onion:443 NetworkBootstrapNodes[] = https://orce4nqoa6muz3gt.onion:443 NetworkBootstrapNodes[] = https://orcwfkilxjxo63mr.onion:443 ; Instruct Tor to establish new circuits by sending the NEWNYM sigal every so ; often. This helps mitigate Tor relays in your path going down after a while. CircuitRefreshInterval = 10M ; Instruct Tor to establish a new rendezvous point for reaching your Orc node ; every so often. This helps mitigate Tor relays in your path going down after ; a while. ServiceRefreshInterval = 35M ; When enabled via &quot;renter&quot; profile, bind a local bridge server that allows for ; GET and POST HTTP requests for uploading and downloading files from the ; network. The bridge will handle encryption and erasure coding for you. ; Optionally, protect the local bridge access using HTTP Basic Authentication ; credentials defined here. BridgeEnabled = 0 BridgeStorageBaseDir = /home/bookchin/.config/orc BridgeHostname = 127.0.0.1 BridgePort = 4445 BridgeAuthenticationEnabled = 0 BridgeAuthenticationUser = orc BridgeAuthenticationPassword = 1b5d3daa16b3343560bcf0377547b1c0 BridgeMetaStoragePath = /home/bookchin/.config/orc/objects.meta BridgeTempStagingBaseDir = /home/bookchin/.config/orc/__bridge.staging BridgeShardAuditInterval = 5DAYS ; Topic codes used when running a renter profile for listening for capacity ; announcements from the network. See the protocol specification for more ; details. It is mostly reccommended to leave these at their default values. RenterListenTopics[] = 01020202 RenterListenTopics[] = 02020202 RenterListenTopics[] = 03020202 ; Path to a file for caching network capacity announcements RenterCapacityCachePath = /home/bookchin/.config/orc/capacity.cache ; Complete information about how orc should connect to the Zcash RPC server. ; Orc needs this to generate addresses for farmers, send payments from renters, ; check balances, etc. WalletHostname = localhost WalletPort = 8232 WalletUser = orc WalletPassword = orc WalletShieldedTransactions = 0 ; Pre-scripted profiles to enable after bootstrapping. ; Renter profiles listen for capacity announcements and build a cache while ; exposing a bridge server for uploading and downloading data. ; Farmer profiles publish capacity announcements and listen for contracts to ; store data. ;ProfilesEnabled[] = renter ;ProfilesEnabled[] = farmer ; Topic codes to use when operating under the farmer profile for subscibing to ; contract publications and announcing capacity. See the protocol specification ; for more details. It is mostly reccommended to leave these at their default ; values. FarmerAdvertiseTopics[] = 01020202 FarmerAdvertiseTopics[] = 02020202 FarmerAdvertiseTopics[] = 03020202 ; How often a farmer profile should scan contract database to reap expired ; shards it is storing. FarmerShardReaperInterval = 24HR ; How often a farmer profile should publish a capacity announcement to it's ; neighboring nodes. FarmerAnnounceInterval = 1HR × Search results Close "},"tutorial-protocol.html":{"id":"tutorial-protocol.html","title":"Tutorial: Protocol Specification","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Node Configuration &amp; SetupProtocol Specification Protocol Specification Orc Protocol SpecificationVersion 2.1 (June 7, 2017)Gordon Hall (gordonh@member.fsf.org)Braydon Fuller (braydon@storj.io)Ryan Foran (ryan@storj.io) 0 LicenseCopyright (C) 2017 Gordon Hall (Orc Protocol)Copyright (C) 2017 Storj Labs, Inc. (Storj Protocol) Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the &quot;LICENSE&quot; file. 1 IntroductionThis specification documents the Orc network protocol in its entirety for the purpose of enabling its implementation in other languages. Described here, is the protocol base - the minimum specification for compatibility with the Orc network. Additional optional extensions to this work are defined as Orc Improvement Proposals (or &quot;IMPs&quot;), some of which have been folded into the base protocol since Version 1, such as SIP-4 and SIP-32 (Storj Protocol). 1.1 Differences from Version 1 All node identities are now hierarchically deterministic (2 Identities) FIND_TUNNEL and OPEN_TUNNEL removed from protocol Introduces capacity publications (6.4 Announcing Capacity) RPC message format changed (4.1 Structure and Authentication) New CLAIM messages allow direct claim of available space (4.11 CLAIM) Clock synchronization with NTP no longer required Nodes communicate exclusively using TLS 2 IdentitiesEvery node (host computer speaking the Orc protocol) on the network possesses a unique cryptographic identity. This identity is used to derive a special 160 bit identifier for the purpose of organizaing the overlay structure and routing messages (3.1: Kademlia). In order for a node to join the network it must generate an identity. Identities are described as hierarchically deterministic and serve the purpose of running a cluster of nodes that can all share the same contracts and act on behalf of each other in the network. The specification extends Bitcoin ECDSA derivation standard BIP32 and BIP43. Key derivation must match the specification of Bitcoin Hierarchical Deterministic Wallets (BIP32) with the purpose field described in Bitcoin Purpose Field for Deterministic Wallets (BIP43). We define the following levels in BIP32 path: m / purpose' / group_index' / node_indexThe apostrophe in the path indicates that BIP32 hardened derivation is used. Purpose is a constant set to 3000, so as to not collide with any bitcoin related proposals which recommends to use the BIP number. m / 3000' / group_index' / node_indexThe group_index for most purposes will be 0. However is reserved for a future use to be able to increment in the case that the contracts should be updated with a new key. The node_index can be a number from 0 through 2 ^ 31 - 1, so that it's using a non-hardened paths and it's always possible to derive the public key for a node using the m / 3000' / group_index' derived extended public key. This gives a total of 2.147 billion possible nodes to run in a group cluster. As noted in BIP32, a compromised private key at the node_index level in combination with the extended public key at the group_index level will compromise all descending private keys derived from the group_index level, this is the rationale for a hardened path for the group_index. In every message exchanged on the network, each party will include a tuple structure which includes enough information to locate and authenticate each party. [&quot;&lt;node_id&gt;&quot;, { /* &lt;contact&gt; */ }]2.1 Node ID GenerationOnce a HD identity has been generated, a child identity should be derived and used for a single node. The resulting public key from that child identity is used to derive the Node ID. The node's identifier is the RIPEMD160( SHA256( CHILD_PUBLIC_KEY ) ) encoded in hexidecimal. This value is inserted as the first item in the identity tuple. [&quot;705e93f855e60847fda4c48adff0dc1b1f7c40ef&quot;, { /* &lt;contact&gt; */ }]2.2 Contact Hash MapThe second entry in the identity tuple contains additional information specific to addressing the node on the network. This includes: { &quot;hostname&quot;: &quot;ip.address.or.domain.name&quot;, &quot;port&quot;: 8443, &quot;protocol&quot;: &quot;https:&quot;, &quot;xpub&quot;: &quot;&lt;child_identity_public_extended_key&gt;&quot;, &quot;index&quot;: &quot;&lt;child_identity_derivation_index&gt;&quot; }Additional properties may be included based on individual use cases within the network, however the properties above are required. 3 Network StructureOrc employs a structured network, meaning that nodes are organized and route messages based on a deterministic metric. The network uses a Kademlia distributed hash table as the basis for the network overlay. In addition to Kademlia, Orc also employs other extensions to mitigate issues and attacks defined by the work on S/Kademlia. In addition to the distributed hash table, Orc also implements a publish-subscribe system, Quasar, atop the Kademlia overlay to provide effective delivery of publications related to the solicitation of storage space (6: Storage Contracts). 3.1 KademliaOnce an Orc node has completed generating its identity, it bootstraps its routing table by following the Kademlia &quot;join&quot; procedure. This involves querying a single known &quot;seed&quot; node for contact information about other nodes that possess a Node ID that is close (XOR distance) to its own _(4.4 FINDNODE). This is done iteratively, sending the same query to the ALPHA (3) results that are closest, until the further queries no longer yield results that are closer or the routing table is sufficiently bootstrapped. 3.2 QuasarUpon successfully bootstrapping a routing table, a node may choose to subscribe to certain publication topics related to types of storage contracts they wish to accept (6.2 Topic Codes). Each node in the network, maintains an attenuated bloom filter, meaning a list of exactly 3 bloom filters, each containing the the topics in which neighboring nodes are interested. Filter 0 [...] - WE are subscribed Filter 1 [...] - 3 NEAREST NEIGHBORS are subscribed Filter 2 [...] - NEIGHBORS' 3 NEAREST NEIGHBORS' are subscribedThe Orc network expects these blooms filters to be constructed and modified in a specific manner. Each filter's bitfield must be exactly 160 bits in size. Items are hashed with FNV in a manner consistent with the paper &quot;Less Hashing, Same Performance: Building a Better Bloom Filter&quot; using 2 slices. To illustrate the hashing in pseudo-code: function calc(key, size = 160, slices = 2) { function fnv(seed, data) { const hash = new FNV(); hash.update(seed); hash.update(data); return hash.value() &gt;&gt;&gt; 0; } const hash1 = fnv(Buffer.from([83]), key); const hash2 = fnv(Buffer.from([87]), key); const hashes = []; for (let i = 0; i &lt; slices; i++) { hashes.push((hash1 + i * hash2) % size); } return hashes; }The above example illustrates how to calculate the values to insert into a bloom filter for a given key (or topic code). To subscribe to a given topic, the code(s) should be processed as shown above and then inserted into the filter at index 0. Once the filter at index 0 represents what the node wants to receive, it must exchange this information with its 3 nearest neighbors (4.7 SUBSCRIBE + 4.8 UPDATE). This allows publications to be properly relayed to nodes who are most likely to be subscribed to the given topic. 3.3 TransportThe Orc network operates entirely over HTTPS. TLS must be used - there is no cleartext supported. In general this means that certificates are self-signed and you must accept them in order to communicate with others on the network. In addition, Orc operates exclusively over Tor and because of this, there is no need to perform certificate pinning for SSL since all Orc nodes are Tor hidden services and authentication is performed by the nature of Tor's routing. Each Orc node exposes endpoints to other nodes; one for receiving RPC messages (4. Remote Procedure Calls), one for serving and accepting raw data streams associated with held contracts (5. Data Transfer Endpoints), and one for delivering identity metadata to requesters (3.4 Root Endpoint). Requests sent to the RPC endpoint require a special HTTP header x-kad-message-id to be included that matches the id parameter in the associated RPC message (4.1 Structure and Authentication). 3.4 Root EndpointWhenver an Orc node receives a GET request at the root path (/), it must with it's contact metadata: [&quot;705e93f855e60847fda4c48adff0dc1b1f7c40ef&quot;, { /* &lt;contact&gt; */ }]This is to enable new Orc nodes who have yet to discover this information to query seeds for it before bootstrapping their routing table. 4 Remote Procedure Calls Method: POST Path: /rpc/ Content Type: application/json Headers: x-kad-message-id 4.1 Structure and AuthenticationEach remote procedure call sent and received between nodes is composed in the same structure. Messages are formatted as a JSON-RPC 2.0 batch payload containing 3 objects. These objects are positional, so ordering matters. The anatomy of a message takes the form of: [{ /* rpc */ },{ /* notification */ },{ /* notification */ }]At position 0 is the RPC request/response object, which must follow the JSON-RPC specification for such an object. It must contain the properties: jsonrpc, id, method, and params if it is a request. It must contain the properties: jsonrpc, id, and one of result or error if it is a response. At positions 1 and 2 are a JSON-RPC notification object, meaning that it is not required to contain an id property since no response is required. These two notifications always assert methods IDENTIFY and AUTHENTICATE respectively. Together, these objects provide the recipient with information regarding the identity and addressing information of the sender as well as a cryptographic signature to authenticate the payload. Positions 3 and beyond in this structure are reserved for future protocol extensions related to global message processing. Example: Request[ { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: &quot;&lt;uuid_version_4&gt;&quot;, &quot;method&quot;: &quot;&lt;method_name&gt;&quot;, &quot;params&quot;: [&quot;&lt;parameter_one&gt;&quot;, &quot;&lt;parameter_two&gt;&quot;] }, { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;IDENTIFY&quot;, &quot;params&quot;: [ &quot;&lt;public_key_hash&gt;&quot;, { &quot;hostname&quot;: &quot;sender.hostname&quot;, &quot;port&quot;: 8443, &quot;protocol&quot;: &quot;https:&quot;, &quot;xpub&quot;: &quot;&lt;public_extended_key&gt;&quot;, &quot;index&quot;: &quot;&lt;child_key_derivation_index&gt;&quot; } ] }, { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;AUTHENTICATE&quot;, &quot;params&quot;: [ &quot;&lt;payload_signature&gt;&quot;, &quot;&lt;child_public_key&gt;&quot;, [&quot;&lt;public_extended_key&gt;&quot;, &quot;&lt;child_key_derivation_index&gt;&quot;] ] } ]Example: Response[ { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: &quot;&lt;uuid_version_4_from_request&gt;&quot;, &quot;result&quot;: [&quot;&lt;result_one&gt;&quot;, &quot;&lt;result_two&gt;&quot;] }, { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;IDENTIFY&quot;, &quot;params&quot;: [ &quot;&lt;public_key_hash&gt;&quot;, { &quot;hostname&quot;: &quot;receiver.hostname&quot;, &quot;port&quot;: 8443, &quot;protocol&quot;: &quot;https:&quot;, &quot;xpub&quot;: &quot;&lt;public_extended_key&gt;&quot;, &quot;index&quot;: &quot;&lt;child_key_derivation_index&gt;&quot; } ] }, { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;AUTHENTICATE&quot;, &quot;params&quot;: [ &quot;&lt;payload_signature&gt;&quot;, &quot;&lt;child_public_key&gt;&quot;, [&quot;&lt;public_extended_key&gt;&quot;, &quot;&lt;child_key_derivation_index&gt;&quot;] ] } ]In the examples above, public_key_hash and child_public_key must be encoded as hexidecimal strings, public_extended_key must be encoded as a base58 string (in accordance with BIP32), and payload_signature must be encoded as a base64 string which is the concatenation of the public key recovery number with the actual signature of the payload - excluding the object at index 2 (AUTHENTICATE). This means that the message to be signed is [rpc, identify]. Note the exclusion of a timestamp or incrementing nonce in the payload means that a man-in-the-middle could carry out a replay attack. To combat this, it is urged that the id parameter of the RPC message (which is a universally unique identifier) be stored for a reasonable period of time and nodes should reject messages that attempt to use a duplicate UUID. The rest of this section describes each individual method in the base protocol and defines the parameter and result signatures that are expected. If any RPC message yields an error, then an error property including code and message should be send in place of the result property. 4.2 PROBEUpon receipt of a PROBE message, the node must attempt to send a PING message to the originator using the declared contact information. If successful, it must respond positively, otherwise error. Used for joining nodes to verify they are publicly addressable. Parameters: []Results: [] 4.3 PINGThis RPC involves one node sending a PING message to another, which presumably replies. This has a two-fold effect: the recipient of the PING must update the bucket corresponding to the sender; and, if there is a reply, the sender must update the bucket appropriate to the recipient. Parameters: []Results: [] 4.4 FIND_NODEBasic kademlia lookup operation that builds a set of K contacts closest to the the given key. The FIND_NODE RPC includes a 160-bit key. The recipient of the RPC returns up to K contacts that it knows to be closest to the key. The recipient must return K contacts if at all possible. It may only return fewer than K if it is returning all of the contacts that it has knowledge of. Parameters: [key_160_hex]Results: [contact_0, contact_1, ...contactN] 4.5 FIND_VALUEKademlia search operation that is conducted as a node lookup and builds a list of K closest contacts. If at any time during the lookup the value is returned, the search is abandoned. If no value is found, the K closest contacts are returned. Upon success, we must store the value at the nearest node seen during the search that did not return the value. A FIND_VALUE RPC includes a B=160-bit key. If a corresponding value is present on the recipient, the associated data is returned. Otherwise the RPC is equivalent to a FIND_NODE and a set of K contacts is returned. If a value is returned, it must be in the form of an object with properties: timestamp as a UNIX timestamp in milliseconds, publisher as a 160 bit public key hash in hexidecimal of the original publisher, and value which may be of mixed type that is valid JSON. Parameters: [key_160_hex]Results: { timestamp, publisher, value } or [...contactN] 4.6 STOREThe sender of the STORE RPC provides a key and a block of data and requires that the recipient store the data and make it available for later retrieval by that key . Parameters: [key_160_hex, { timestamp, publisher, value }]Results: [key_160_hex, { timestamp, publisher, value }] 4.7 SUBSCRIBEUpon receipt of a SUBSCRIBE message, we simply respond with a serialized version of our attenuated bloom filter. Senders of this message must merge the response with their local attenuated bloom filter starting at their filter at index 1. Parameters: []Results: [filter_0_hex, filter_1_hex, filter_2_hex] 4.8 UPDATEUpon receipt of an UPDATE message we merge the delivered attenuated bloom filter with our own. This is the inverse of SUBSCRIBE, where a peer requests a copy of our attenuated bloom filter. Parameters: [filter_0_hex, filter_1_hex, filter_2_hex]Results: [] 4.9 PUBLISHUpon receipt of a PUBLISH message, we validate it, then check if we or our neighbors are subscribed. If we are subscribed, we execute our handler. If our neighbors are subscribed, we relay the publication to ALPHA random of the closest K. If our neighbors are not subscribed, we relay the publication to a random contact. The parameters for a PUBLISH message are named, not positional. It must be a JSON object containing: uuid, a version 4 UUID string, topic, the topic string to which a node may be subscribed, publishers, an array of 160 bit public key hash strings in hexidecimal representing nodes that have relayed the message previously, ttl the number of hops left for relaying the publication, and contents, any arbitrary valid JSON data associated with the publication. Given the relatively high cost of a single publication's propagation through the overlay, nodes should take care to implement some reasonable rate limiting for relay of publications. It is advisable for nodes to ignore the ttl and refuse to relay a publication if the identifier at publishers[0] is matched as the originator more than 100 times within a minute. Before relaying the message to others, we must add our public key hash to the publishers list and decrement the ttl. Parameters: { uuid, topic, publishers, ttl, contents }Results: [] 4.10 OFFERUpon receipt of an OFFER message, nodes must validate the descriptor, then ensure that the referenced shard is awaiting allocation(s). If both checks succeed, then the descriptor is added to the appropriate offer processing stream. Once the descriptor is processed, we respond back to the originator with the final copy of the contract (6.1 Descriptor Schema). These messages are generally sent based on information collected when subscribed to renter contract publications. Parameters: [descriptor_map]Results: [descriptor_map] 4.11 CLAIMUpon receipt of an CLAIM message, nodes must validate the descriptor, then ensure that there is enough available space for the shard. If both checks succeed, then the descriptor is signed and returned along with a consignment token so the initiating renter can immediately upload the data. This call is the functional inverse of OFFER, as it is used for a renter to signal to a farmer that it wishes to rent capacity. These messages are generally sent based on information collected when subscribed to farmer capacity publications. Parameters: [descriptor_map]Results: [descriptor_map, token_256_hex] 4.11 CONSIGNUpon receipt of a CONSIGN message, the node must verify that it has a valid storage allocation and contract for the supplied hash and identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: [hash_160_hex]Results: [token_256_hex] 4.12 AUDITUpon receipt of an AUDIT message, the node must look up the contract that is associated with each hash-challenge pair in the payload, prepend the challenge to the shard data, and caclulate the resulting hash, formatted as a compact proof (7 Retrievability Proofs). Parameters: [...{ hash, challenge }]Results: [...{ hash, proof }] 4.13 MIRRORUpon receipt of a MIRROR message, the node must verify that it is in possesion of the shard on behalf of the identity or the message originator. If so, given the token-hash pair, it must attempt to upload it's copy of the shard to the target to establish a mirror. The originator must have an established contract with the target node and have issued a CONSIGN message to the target in advance to provide the MIRROR recipient with this token. In addition to the hash and token, the sender must also include the target contact data in the form of [public_key_hash, { hostname, port, xpub, index, protocol }]. Parameters: [hash_160_hex, token_256_hex, target_contact]Results: [status_message_string] 4.14 RETRIEVEUpon receipt of a RETRIEVE message, the node must verify that it is in possession of the shard on behalf of the identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: [hash_160_hex]Results: [token_256_hex] 4.15 RENEWUpon receipt of a RENEW message, the recipient farmer must extend or terminate it's contract based on the new terms supplied by the renter. If the renewal descriptor is valid and complete, the farmer must store the updated version after signing and respond back to the originator with the version containing the updated signature (6.1 Descriptor Schema). Implementations should only allow certain properties to be updated: renter_id, renter_hd_key, renter_signature, store_begin, store_end, audit_leaves. If the sender has attempted to modify any other parts of the contract, an error should be returned. Parameters: [descriptor_map]Results: [descriptor_map] 5 Data Transfer EndpointsInitiating the transfer of data between nodes after a contract has been signed is straightforward. First, the initiator must request a transfer token from the custodian. If uploading the shard for the first time to a farmer, a CONSIGN RPC (4.13 CONSIGN) must be sent. If downloading the shard, a RETRIEVE RPC (4.14 RETRIEVE) is sent. The result of either of those messages should yield an authorization token that is included in the query string of the next request. 5.1 Uploading Method: POST Path: /shards/{hash}?token={consign_token} Content Type: binary/octet-stream 5.2 Downloading Method: GET Path: /shards/{hash}?token={retrieve_token} Content Type: binary/octet-stream 6 Storage ContractsNodes on the Orc network form agreements with each other regarding the storage of data by exchanging a &quot;contract descriptor&quot;. These descriptors are included in contract publications intended to solicit storage space (7 Renting Space) as well as in RENEW messages (4.15 RENEW). Contracts describe identifying attributes of the data, the parties involved, terms of payment, and information about audits (8 Audit Preparation). 6.1 Contract Descriptor SchemaContracts are structured as a flat JSON dictionary and includes cryptographic signatures from the parties involved. The properties that compose a contract are show as follows. version Integer Unique identifier for the contract (this is version 1) renter_hd_key String Node extended public key in base58 renter_hd_index Integer Derivation index for signature renter_id String Node ID of the renter renter_signature String Renter's cryptographic signature farmer_hd_key String Node extended public key in base58 farmer_hd_index Integer Derivation index for signature farmer_id String Node ID of the farmer farmer_signature String Farmer's cryptographic signature data_size Integer Number of bytes to store data_hash String RIPEMD-160 SHA-256 hash of the data store_begin Integer UNIX timestamp to start contract in milliseconds store_end Integer UNIX timestamp to end the contract in milliseconds audit_count Integer Number of audits renter will perform audit_leaves Array Merkle leaves for audit tree as hexidecimal strings payment_storage_price Integer Price for storage in non-divisible unit payment_download_price Integer Price per download in non-divisible unit payment_destination String Address to send funds (Etheruem) For a completed and valid contract, all fields be assigned a value and both the renter and farmer must sign the contract, placing their signatures in the respective fields. The signature is generated by using the private key associated with the renter_id or farmer_id, which is the hash of the public key. The signature field must be the result of the public key recovery number prepended to the actual signature of the JSON formatted descriptor exluding both signature fields and all other fields sorted alphanumerically. The signature must be encoded as a base64 string. 6.2 Topic CodesOrc defines a matrix of criteria and descriptors in the form of codes representing the degree of which the criteria must be met. The resulting topic code is used as the key for cross-referencing neighborhood bloom filters to determine how the publication should be routed. At the time of writing, there are 4 criteria column in the topic matrix: Size: refers to the size of the data to be stored Duration: refers to the length of time which the data should be stored Availability: refers to the relative uptime of required by the contract Speed: refers to the throughput desired for retrieval of the stored data At the time of writing, there are 3 descriptor opcodes representing low, medium, and high degrees of the criteria. Low: 0x01 Medium: 0x02 High: 0x03 The ranges represented by these descriptors are advisory and may change based on network performance and improvements to hardware over time. When publishing or subscribing to a given topic representing the degrees of these criteria, nodes must serialize the opcodes as the hex representation of the bytes in proper sequence. This sequence is defined as: prefix + size + duration + availability + speed. The prefix byte is the static identifier for a type of publication. This may include both capacity announcements (6.4 Announcing Capacity) and contract publications (6.3 Renting Space). The prefix acts as a namespace for a type of publication topic. The prefix for a contract publication is 0x0f and the prefix for a capacity announcement is 0x0c, followed by the topic-criteria sequence. To illustrate by example, we can determine the proper topic by analyzing the use case for a given file shard. For instance, if we want to store an asset that is displayed on a web page we can infer the following: The file is small The file may change often, so we should only store it for medium duration The file needs to always be available The file should be transferred quickly Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x01, 0x02, 0x03, 0x03]. Serialized as hex, our topic string becomes: 0f01020303. Another example, by contrast, is data backup. Data backup is quite different than the previous example: The file is large (perhaps part of a hard drive backup) The file will not change and should be stored long term The file will not be accessed often, if ever The file does not need to be transferred at high speed Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x03, 0x03, 0x01, 0x01]. Serialized as hex, our topic string becomes: 0f03030101. 6.3 Renting SpaceWhen a node wishes to solicit storage capacity for a shard, it must know which nodes are both accepting contracts and have the available space. Short lived nodes renting data, like nodes who join for the sole purpose of storing some data then leave, will likely not stick around long enough to track enough capactity announcements (6.4 Announcing Capacity) to build a local cache of known farmers with space. For these nodes, they must publish a shard descriptor and wait for offers from farmers as the message propagates the overlay (3.2 Quasar + 4.10 OFFER). To publish a shard descriptor, a contract must be constructed (6.1 Contract Descriptor Schema) and included in the contents value of a PUBLISH message (4.9 PUBLISH) sent to the renting node's 3 nearest neighbors to the data_hash key in the descriptor (this helps even the distribution). When publishing the descriptor, an appropriate topic code should be used (6.2 Topic Codes), prefixed with 0x0f (0f when serialized as hexidecimal). The descriptor must be as complete as possible, including values for all keys except for any that are prefixed with farmer_ and payment_destination. The contents property should also include the renter's contact information so that farmers who wish to submit offers are not required to perform a network walk to find the originator if it is not already in it's routing table. The value of this property should be: [{ descriptor }, [ identity, { contact } ]]Once these messages have been dispatched, received, and acknowledged, the sender will begin receiving offers from farmers. The payload for these offers will include a completed version of the descriptor which was originally published, but include values for the properties prefixed with farmer_. The publisher, if it chooses to accept the completed contract, must sign the descriptor again and respond to the offering farmer with the finalized contract. Once this exchange is complete, the renting node may request consignment to the node(s) with whom it is now contracted (4.11 CONSIGN) and transfer the shard (5.1 Uploading). 6.4 Announcing CapacityWhen a node joins the network and wishes to make some storage capacity available to others, it can subscribe to contract publication topics (using the 0x0f topic code prefix) and wait for contracts for which an offer can be dispatched. However, in addition to this, a farming node can proactively inform the network that it has available space. To announce capacity, a node must send a PUBLISH message to it's 3 nearest neighbors for each topic code it is willing to allow, prefixed with the capacity code 0x0c (0c when serialized as hexidecimal). The contents property should contain the number of bytes available for claim along with the farmer's contact information so that renters who wish to claim space are not required to perform a network walk to find the originator if it is not already in it's routing table. The value of this property should be: [ { allocated, available }, [ identity, { contact } ] ]Long lived renter nodes, like those operated by a Bridge or other similar directory services on the network, may subscribe to these capacity announcements and maintain a backlog cache of farmers who have space available. This allows these renting nodes to directly claim space and transfer data to the farmer without the overhead of publishing a contract descriptor and waiting for offers (4.11 CLAIM). Farmers who announce capacity should do so on a reasonable interval to ensure that renters tracking their state have fresh information. It is reccommended to publish capacity announcements once per hour and no more than once per 15 minutes. Nodes should take care to refuse to relay publications originating from an identity who has published a capacity announcement more than 100 times within the last hour. 7 Retrievability ProofsWhen the custodian of a data shard receives an audit (4.12 AUDIT), it is expected to respond with proof that it still in possession of the shard. This works by computing a retrievability proof structure from a provided challenge. Upon receipt of a hash-challenge pair, the associated data is prepended with the challenge bytes and hashed: RIPEMD160( SHA256( CHALLENGE + DATA ) )The result of this operation yields a value that, when hashed again, equals one of the bottom leaves of the audit tree (8 Audit Preparation). In addition to supplying this single-hashed value as proof that the farmer is still honoring the terms of the contract, the farmer must also provide the uncles required to rebuild the merkle tree. This proof response is specified as a series of nested JSON arrays. [[[[[&quot;&lt;response&gt;&quot;],&quot;&lt;uncle&gt;&quot;],&quot;&lt;uncle&gt;&quot;],&quot;&lt;uncle&gt;&quot;],&quot;&lt;uncle&gt;&quot;]For clarification, given a simple merkle tree: +-- HASH_0 (Root) | +-- HASH_1 | | +-- HASH_3 | | +-- HASH_4 | +-- HASH_2 | | +-- HASH_5 | | +-- HASH_6 = ( RIPEMD160( SHA256( CHALLENGE_RESPONSE ) ) )The resulting format of a proof for an audit matching HASH_6 would appear as: [HASH_1, [HASH_5, [CHALLENGE_RESPONSE]]]The resulting format of a proof for an audit matching HASH_3 would appear as: [[[CHALLENGE_RESPONSE], HASH_5], HASH_2]Upon receipt of the farmer's proof, the renter must verify that the proof is valid by using it to rebuild the merkle tree. If the proof is verified successfully, the renter is expected to issue a payment to the payment_destination defined in the original contract. The amount of the payment should be equal to: payment_storage_price / audit_count in addition to payment_download_price * downloads_since_last_audit. If the verification fails then the contract is null and no payment is required. Conversely, if the verification succeeds and the renter does not issue the payment in a timely manner, then the contract is also null and the farmer may decide to cease storage of the data. 8 Audit PreparationBefore a renter node published a contract or claims a capacity allocation, it must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the audit_count defined in the contract descriptor and be included in the descriptor's audit_tree. A challenge is simply 32 random bytes encoded as hexidecimal. The generated challenges must not be shared until the renter wishes to issue an AUDIT RPC for proof-of-retrievability. An audit_tree contains the bottom leaves of a Merkle Tree. Each of the bottom leaves of the tree must be equal to the double RIPEMD160( SHA256 ( challenge + shard ) ) encoded as hexidecimal. In order to ensure that the resulting merkle tree is properly balanced, the number of bottom leaves must be equal to the next power of 2 of the audit count. To ensure this, the additional leaves can simply be the double RIPEMD160( SHA256 ( NULL ) ) (the same hash function for an audit, but applied to an empty buffer). To audit a farmer is to request proof that it is still honoring the terms of the storage contract without the need to have it supply the entire shard of data. To do this, the renter must supply the farmer with one of the secret pre-calculated challenges (4.12 AUDIT). The receiving farmer must respond with a retrievability proof (7 Retrievability Proofs). 9 References Orc Improvement Proposals (https://github.com/orcproject/imps) BIP32 (https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) BIP43 (https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) Kademlia (http://www.scs.stanford.edu/~dm/home/papers/kpos.pdf) S/Kademlia (http://www.tm.uka.de/doc/SKademlia_2007.pdf) Quasar (https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/iptps08-quasar.pdf) FNV (https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) Less Hashing, Same Performance: Building a Better Bloom Filter (http://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf) Merkle Tree (https://en.wikipedia.org/wiki/Merkle_tree) × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
