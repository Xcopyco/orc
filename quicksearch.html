<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_audit.js.html":{"id":"lib_audit.js.html","title":"Source: lib/audit.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/audit.js 'use strict'; const { Writable: WritableStream } = require('stream'); const assert = require('assert'); const crypto = require('crypto'); const constants = require('./constants'); const MerkleTree = require('mtree'); const utils = require('./utils'); /** * Represents a streaming audit challenge generator */ class Audit extends WritableStream { /** * @constructor * @param {number} audits - Total number of challenges to generate */ constructor(audits) { super(); assert(typeof audits === 'number', 'Invalid number of audits supplied'); assert(!Number.isNaN(audits), 'Invalid number of audits supplied'); assert(Number.isFinite(audits), 'Invalid number of audits supplied'); this._audits = audits; this._finished = false; this._challenges = []; this._inputs = this._prepareChallenges(); this.on('finish', this._generateTree.bind(this)); } /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ getPublicRecord() { assert(this._finished, 'Challenge generation is not finished'); return this._tree.level(this._tree.levels() - 1) .map((i) =&gt; i.toString('hex')); } /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ getPrivateRecord() { assert(this._finished, 'Challenge generation is not finished'); return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges.map((i) =&gt; i.toString('hex')) }; } /** * Implements the underlying write method * @private */ _write(bytes, encoding, next) { this._inputs.forEach((input, i) =&gt; { if (i &lt; this._audits) { input.update(bytes); } }); next(); } /** * Prepares the challenge hasher instances * @private */ _prepareChallenges() { let iterations = 0; let inputs = []; while (iterations &lt; this._audits) { const challenge = this._generateChallenge(); const input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return inputs; } /** * Generate the audit merkle tree from a series of challenges * @private */ _generateTree() { this._finished = true; this._tree = new MerkleTree(this._inputs.map((input, i) =&gt; { if (i &gt;= this._audits) { return input; } else { return utils.rmd160sha256(utils.rmd160(input.digest())); } }), utils.rmd160sha256); } /** * Generate a random challenge buffer * @private * @returns {buffer} */ _generateChallenge() { return crypto.randomBytes(constants.AUDIT_BYTES); } /** * Create a challenge response input to merkle tree * @private */ _createResponseInput(challenge) { return crypto.createHash('sha256').update(challenge); } /** * Returns a new instance from the predefined challenges and tree * @param {array} challenges - The precomputed challenges * @param {array} tree - The bottom leaves of the existing merkle tree * @returns {Audit} */ static fromRecords(challenges, tree) { assert(Array.isArray(challenges), 'Invalid challenges supplied'); assert(Array.isArray(tree), 'Invalid tree supplied'); assert( tree.length === utils.getNextPowerOfTwo(challenges.length), 'Challenges and tree do not match' ); tree = tree.map((i) =&gt; Buffer.from(i, 'hex')); const auditor = new Audit(challenges.length); auditor._challenges = challenges; auditor._tree = new MerkleTree(tree, utils.rmd160sha256); auditor._finished = true; return auditor; } } module.exports = Audit; × Search results Close "},"lib_bridge.js.html":{"id":"lib_bridge.js.html","title":"Source: lib/bridge.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/bridge.js 'use strict'; const BusBoy = require('busboy'); const ReedSolomon = require('@ronomon/reed-solomon'); const Zcash = require('zcash'); const http = require('http'); const utils = require('./utils'); const fs = require('fs'); const merge = require('merge'); const connect = require('connect'); const auth = require('basic-auth'); const crypto = require('crypto'); const { tmpdir } = require('os'); const path = require('path'); const tiny = require('tiny'); const mkdirp = require('mkdirp'); const uuid = require('uuid'); const AuditStream = require('./audit'); const Contract = require('./contract'); /** * Represents a local HTTP(s) server that abstracts the upload and download * of files away to a simple request. Files are encrypted to the given public * key, split into shards for erasure codes. Prepped for distribution and * queued for storing in the network. Bridge exposes a simple API for getting * status of transfers and previously stored objects. * * GET / (List objects as JSON) * GET /{hash} (Download object) * DELETE /{hash} (Delete object) * POST / (Upload object - Multipart) */ class Bridge { static get DEFAULTS() { return { auth: { user: null, pass: null }, store: path.join( tmpdir(), `objects.${crypto.randomBytes(16).toString('hex')}` ), stage: path.join( tmpdir(), `staging.${crypto.randomBytes(16).toString('hex')}` ), capacityCache: null, auditInterval: 432000000 // 5 days }; } /** * @constructor * @param {Node} node */ constructor(node, options) { this.options = merge(Bridge.DEFAULTS, options); this.objects = tiny(this.options.store); this.node = node; this.server = http.createServer(this.createRequestHandler()); if (!fs.existsSync(this.options.stage)) { mkdirp.sync(this.options.stage); } setInterval(() =&gt; this.audit(), 21600000); // 6 hours } /** * Listens on the given port and hostname * @param {number} port * @param {string} hostname * @param {function} callback */ listen() { this.server.listen(...arguments); } /** * Creates request router and handler stack * @returns {function} */ createRequestHandler() { const handler = connect(); handler.use(this.authenticate.bind(this)); handler.use('/', this.route.bind(this)); handler.use(this.error.bind(this)); return handler; } /** * Handles request authentication if defined * @param {object} request * @param {object} response * @param {function} next */ authenticate(req, res, next) { const { user, pass } = this.options.auth; const error = new Error('Not authorized'); error.code = 401; if (user &amp;&amp; pass) { const creds = auth(req); if (!(creds.name === user &amp;&amp; creds.pass === pass)) { return next(error); } } next(); } /** * Responds to requests with error code and message * @param {error} error * @param {object} request * @param {object} response * @param {function} next */ error(err, req, res, next) { if (!err) { return next(); } res.writeHead(err.code); res.write(err.message); res.end(); } /** * Handles routing requests to their appropriate handler * @param {object} request * @param {object} response * @param {function} next */ route(req, res, next) { const { method, url } = req; function badRequest() { let error = new Error(`Cannot ${method} ${url}`); error.code = 400; next(error); } if (method === 'POST') { if (url !== '/') { badRequest(); } else { this.upload(req, res, next); } } else if (method === 'GET') { if (url === '/') { this.list(req, res, next); } else { this.download(req, res, next); } } else if (method === 'DELETE') { if (url === '/') { badRequest(); } else { this.destroy(req, res, next); } } else { badRequest(); } } /** * Scans the object database and returns all index entries * @param {object} request * @param {object} response * @param {function} next */ list(req, res, next) { let written = 0; res.writeHead(200, { 'Content-Type': 'application/json' }); res.write('[') this.objects.each((obj) =&gt; { res.write((written === 0 ? '' : ',') + JSON.stringify(obj)); written++; }); res.write(']'); res.end(); } /** * Queues the object for upload to the network * @param {object} request * @param {object} response * @param {function} next */ upload(req, res, next) { res.writeHead(501); res.end('Not Implemented'); const busboy = new BusBoy({ headers: req.headers }); const objects = []; busboy.on('file', (field, file, name, encoding, mime) =&gt; { const tmp = path.join(this.options.stage, uuid.v4()); mkdirp.sync(tmp); let size = 0; const hash = crypto.createHash('sha256'); const hasher = new stream.Transform({ transform: (data, enc, cb) =&gt; { size += data.length; hash.update(data); cb(null, data); } }); const writer = fs.createWriteStream(path.join(tmp, 'ciphertext')); const cipher = utils.createCipher(this.node.spartacus.publicKey, this.node.spartacus.privateKey); file.pipe(hasher).pipe(cipher).pipe(writer).on('finish', () =&gt; { const digest = hash.digest('hex'); const stage = path.join(this.options.stage, digest); const ciphertext = path.join(stage, 'ciphertext'); fs.renameSync(tmp, stage); objects.push({ hash: digest, encoding, mimetype: mime }); this.distribute(ciphertext, { encoding, mimetype: mime }); this.objects.save(digest, { name, encoding, mimetype: mime, hash: digest, size, status: 'queued', shards: [] }, () =&gt; null); }); }); busboy.on('finish', () =&gt; { res.writeHead(201, { 'Content-Type': 'application/json' }); res.write(JSON.stringify(objects)); res.end(); }); req.pipe(busboy); } /** * Takes the supplied file path and applies erasure codes, then attempts to * distribute the shards across the network * @param {string} filepath - Path to the file to distribute * @param {object} metadata * @param {string} metadata.encoding * @param {string} metadata.mimetype * @param {string} metadata.hash * @returns {EventEmitter} */ distribute(filepath, metadata) { const stat = fs.statSync(filepath); const rsparams = utils.getErasureParameters(stat.size); const rs = new ReedSolomon(rsparams.shards, rsparams.parity); function encodeErasure(callback) { fs.readFile(filepath, (err, file) =&gt; { if (err) { return callback(err); } let parity = []; let { size } = rsparams; for (let i = 0; i &lt; rsparams.parity; i++) { parity.push(new Buffer(rsparams.size)); } file = Buffer.concat([file, Buffer.concat(parity)]); rs.encode(file, 0, file.length, size, 0, size, (err) =&gt; { if (err) { return callback(err); } this.objects.get(metadata.hash, (err, object) =&gt; { if (err) { return callback(err); } else { callback(null, file, rsparams, object); } }); }); }); } function prepareShards(file, rsparams, object, callback) { let time = Date.now(); let shards = []; let position = 0; function prepareContracts() { async.eachSeries(shards, (shard, next) =&gt; { const audit = new AuditStream(3); // TODO: Configurable const stream = fs.createReadStream(shard.path); const hash = crypto.createHash('sha256'); const hasher = new stream.Transform({ transform: (data, enc, cb) =&gt; { hash.update(data); cb(null, data); } }); stream.pipe(hasher).pipe(audit).on('finish', () =&gt; { shard._audits = audit.getPrivateRecord(); shard._proposal = Contract.from({ data_hash: utils.rmd160(hash.digest()).toString('hex'), data_size: rsparams.size, audit_count: 3, // TODO: Configurable audit_leaves: audit.getPublicRecord(), payment_storage_price: 0, // TODO: Configurable payment_download_price: 0, // TODO: Configurable store_begin: time, store_end: time + ms('90d'), // TODO: Configurable renter_hd_key: this.node.contact.xpub, renter_hd_index: this.node.contact.index, renter_id: this.node.identity.toString('hex') }); shard._proposal.sign('renter', this.node.spartacus.privateKey); next(); }); }, () =&gt; { object.shards = shards; this.object.save(object.hash, object, () =&gt; callback(null, object)); }); } async.times(rsparams.shards + rs.params.parity, (n, done) =&gt; { const pad = (n) =&gt; n &gt;= 10 ? n.toString() : `0${n}`; const shardpath = path.join(path.dirname(filepath), `${pad(n)}.shard`); fs.writeFile(shardpath, file.slice(position, rsparams.size), () =&gt; { position += rsparams.size; shards.push({ index: n, size: rsparams.size, path: shardpath }); done(); }); }, () =&gt; { fs.unlink(filepath, () =&gt; prepareContracts()); }); } function uploadShards(shards, object, callback) { // TODO: Publish or claim a contract for each shard // TODO: Upload each shard to respective farmer node // TODO: Keep object pointer updated for retrieval later callback(null); } async.waterfall([ (next) =&gt; encodeErasure(next), (file, rs, obj, next) =&gt; prepareShards(file, rs, obj, next), (shards, obj, next) =&gt; uploadShards(shards, obj, next) ], (err) =&gt; { this.node.logger.error(err.message); }); } /** * Downloads the object from the network * @param {object} request * @param {object} response * @param {function} next */ download(req, res, next) { res.writeHead(501); res.end('Not Implemented'); // TODO: Lookup object and get shard pointers // TODO: Request a download token for each shard // TODO: Download each shard (minimum RS?) // TODO: Respond to request with decrypted stream } /** * Ends contracts with farmers for the object parts and removes * reference to them * @param {object} request * @param {object} response * @param {function} next */ destroy(req, res, next) { res.writeHead(501); res.end('Not Implemented'); // TODO: For each shard referenced by the object // TODO: Set the store_end time in the contract to now // TODO: Issue a RENEW message to the associated farmer node // TODO: Issue any final payment for storage // TODO: Remove the object reference // TODO: Respond immediately after queuing the destroy // TODO: (Status can be checked with GET /) } /** * Periodically call this to scan the object store for shards that need to * be audited, perform audit, and issue payment * @param {function} callback */ audit(callback) { callback(new Error('Auditor not implemented')); } } module.exports = Bridge; × Search results Close "},"lib_contract.js.html":{"id":"lib_contract.js.html","title":"Source: lib/contract.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/contract.js 'use strict'; const ms = require('ms'); const merge = require('merge'); const JSONSchema = require('jsen'); const stringify = require('json-stable-stringify'); const constants = require('./constants'); const utils = require('./utils'); const secp256k1 = require('secp256k1'); const { utils: keyutils } = require('kad-spartacus'); /** * Represents a storage contract between a renter and a farmer */ class Contract { /** * @constructor * @param {object} contract * @param {string} contract.type - Unique identifier for the contract * @param {string} [contract.renter_hd_key] - Node extended public key in base58 * @param {number} [contract.renter_hd_index] - Derivation index for signature * @param {string} contract.renter_id - Node ID of the renter * @param {string} contract.renter_signature - Renter's cryptographic signature * @param {string} [contract.farmer_hd_key] - Node extended public key in base58 * @param {number} [contract.farmer_hd_index] - Derivation index for signature * @param {string} contract.farmer_id - Node ID of the farmer * @param {string} contract.farmer_signature - Farmer's cryptographic signature * @param {number} contract.data_size - Number of bytes to store * @param {string} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {number} contract.store_begin - UNIX timestamp to start contract * @param {number} contract.store_end - UNIX timestamp to end the contract * @param {number} contract.audit_count - Number of audits renter will perform * @param {string[]} contract.audit_leaves - Merkle leaves for audit tree * @param {number} contract.payment_storage_price - Total price for storage * @param {number} contract.payment_download_price - Price per download * @param {string} contract.payment_destination - Zcash address to send funds * @param {object} criteria * @param {number} criteria.size - Criteria degree OPCODE * @param {number} criteria.duration - Criteria degree OPCODE * @param {number} criteria.availability - Criteria degree OPCODE * @param {number} criteria.speed - Criteria degree OPCODE */ constructor(contract, criteria) { this._properties = merge(Contract.DEFAULTS, contract); this._criteria = this._inferCriteria(criteria); this._clean(); } /** * Defines the JSON Schema of a {@link Contract} * @static */ static get schema() { return { type: 'object', properties: { version: { type: ['integer'], minimum: 0 }, renter_hd_key: { type: ['string', 'boolean'], pattern: '^[1-9a-km-zA-HJ-NP-Z]{1,111}$' }, renter_hd_index: { type: ['integer', 'boolean'], minimum: 0, maximum: 2147483647 }, renter_id: { type: ['string', 'null'], pattern: '[A-Fa-f0-9]{40}$' }, renter_signature: { type: ['string', 'null'] }, farmer_hd_key: { type: ['string', 'boolean'], pattern: '^[1-9a-km-zA-HJ-NP-Z]{1,111}$' }, farmer_hd_index: { type: ['integer', 'boolean'], minimum: 0, maximum: 2147483647 }, farmer_id: { type: ['string', 'null'], pattern: '[A-Fa-f0-9]{40}$' }, farmer_signature: { type: ['string', 'null'] }, data_size: { type: ['integer', 'null'], minimum: 0 }, data_hash: { type: ['string', 'null'], pattern: '^[0-9a-f]{40}$' }, store_begin: { type: ['integer', 'null'], minimum: 0 }, store_end: { type: ['integer', 'null'], minimum: 0 }, audit_count: { type: ['integer', 'null'], minimum: 0 }, audit_leaves: { type: 'array', items: { type: 'string', pattern: '[A-Fa-f0-9]$' } }, payment_storage_price: { type: ['integer', 'null'] }, payment_download_price: { type: ['integer', 'null'] }, payment_destination: { type: ['string', 'null'] } } }; } /** * Validation function against the schema * @static */ static get validator() { return JSONSchema(Contract.schema); } /** * Defines some default properties of a {@link Contract} * @static */ static get DEFAULTS() { return { version: 1, renter_hd_key: false, renter_hd_index: false, renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, audit_leaves: [], payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; } /** * Defines some default criteria of a {@link Contract} * @static */ static get CRITERIA() { return { size: constants.OPCODE_DEG_MED, duration: constants.OPCODE_DEG_MED, availability: constants.OPCODE_DEG_MED, speed: constants.OPCODE_DEG_MED }; } /** * Defines the criteria matrix for a {@link Contract} * @static */ static get MATRIX() { return { size: function(size) { if (size &gt; 0 &amp;&amp; size &lt;= (32 * 1024 * 1024)) { return constants.OPCODE_DEG_LOW; } if (size &gt; (32 * 1024 * 1024) &amp;&amp; size &lt;= (512 * 1024 * 1024)) { return constants.OPCODE_DEG_MED; } if (size &gt; (512 * 1024 * 1024) &amp;&amp; size &lt;= (4096 * 1024 * 1024)) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, duration: function(duration) { if (duration &gt; 0 &amp;&amp; duration &lt;= ms('30d')) { return constants.OPCODE_DEG_LOW; } if (duration &gt; ms('30d') &amp;&amp; duration &lt;= ms('90d')) { return constants.OPCODE_DEG_MED; } if (duration &gt; ms('90d') &amp;&amp; duration &lt;= ms('320d')) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, availability: function(availability) { if (availability &gt;= 0.5 &amp;&amp; availability &lt;= 0.7) { return constants.OPCODE_DEG_LOW; } if (availability &gt; 0.7 &amp;&amp; availability &lt;= 0.9) { return constants.OPCODE_DEG_MED; } if (availability &gt; 0.9 &amp;&amp; availability &lt;= 1) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; }, speed: function(speed) { if (speed &gt; 0 &amp;&amp; speed &lt;= 6) { return constants.OPCODE_DEG_LOW; } if (speed &gt; 6 &amp;&amp; speed &lt;= 12) { return constants.OPCODE_DEG_MED; } if (speed &gt; 12 &amp;&amp; speed &lt;= 32) { return constants.OPCODE_DEG_HIGH; } return constants.OPCODE_DEG_HIGH; } }; } /** * Removes all properties not in the schema from contract * @private * @param {object} criteria - Criteria degree opcodes * @returns {object} */ _inferCriteria(criteria) { let opcodes = Contract.CRITERIA; opcodes.size = Contract.MATRIX.size(this.get('data_size')); opcodes.duration = Contract.MATRIX.duration( this.get('store_end') - this.get('store_begin') ); return merge(opcodes, criteria); } /** * Removes all properties not in the schema from contract * @private * @returns {Contract} */ _clean() { const keys = Object.keys(Contract.schema.properties); for (let field in this._properties) { if (!keys.includes(field)) { delete this._properties[field]; } } return this; } /** * Validates the contract specification * @private * @returns {boolean} validity */ isValid() { return Contract.validator(this._properties); } /** * Checks if the contract is complete * @returns {boolean} completed */ isComplete() { for (let prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; } /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @returns {string} */ getSigningData() { const sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); } /** * Signs the contract as the given actor * @param {string} actor - One of 'farmer' or 'renter' * @param {buffer} secret - ECDSA private key * @returns {string} signature */ sign(actor, secret) { return this.set(actor + '_signature', this.signExternal(secret).toString('base64')); } /** * Verify the contract signature for the given actor * @param {string} actor - One of 'farmer' or 'renter' * @returns {boolean} */ verify(actor) { const compactSig = Buffer.from(this.get(`${actor}_signature`), 'base64'); const recovery = compactSig[0]; const signature = compactSig.slice(1); const message = utils.sha256(Buffer.from(this.getSigningData())); const pubkey = secp256k1.recover(message, signature, recovery, true); const pubkeyhash = this.get(`${actor}_id`); return this.verifyExternal(signature, pubkey) &amp;&amp; keyutils.toPublicKeyHash(pubkey).toString('hex') === pubkeyhash; } /** * Signs the contract with the proved key and returns the signature * @param {buffer} secret - ECDSA private key * @returns {buffer} */ signExternal(secret) { const { signature, recovery } = secp256k1.sign( utils.sha256(Buffer.from(this.getSigningData())), secret ); return Buffer.concat([Buffer.from([recovery]), signature]); } /** * Verify the provided signature for the contract * @param {buffer} signature - The contract signature to verify * @param {buffer} pubkey - ECDSA public key * @returns {boolean} */ verifyExternal(signature, pubkey) { return secp256k1.verify( utils.sha256(Buffer.from(this.getSigningData())), signature, pubkey ); } /** * Applies the provided fields to the contract and validates it * @param {object} fields - Contract properties to update * @returns {Contract} */ update(fields) { for (let prop in fields) { this.set(prop, fields[prop]); } return this; } /** * Returns the value for the given contract property * @param {string} field - Contract property to get * @returns {string|number|null} value */ get(field) { return this._properties[field]; } /** * Sets the contract property to the given value * @param {string} field - Contract property to set * @param {string|number} value - Value to set for field * @returns {string|number|null} */ set(field, value) { this._properties[field] = value; this._clean(); return this._properties[field]; } /** * Calculates the SHA-256 hash of the serialized contract * @returns {buffer} */ getHash() { return utils.sha256(this.toBuffer()); } /** * Return OPCODE byte sequence for contract publication topic * @returns {buffer} */ getTopicBuffer() { return Contract.createTopic(this._criteria); } /** * Return OPCODE byte sequence for contract publication topic as hex string * @returns {string} */ getTopicString() { return this.getTopicBuffer().toString('hex'); } /** * Converts the contract to a plain object * @returns {object} */ toObject() { return JSON.parse(this.toJSON()); } /** * Converts the contract to JSON string * @returns {string} */ toJSON() { return stringify(this._properties); } /** * Converts the contract to Buffer * @returns {buffer} */ toBuffer() { return new Buffer(this.toJSON(), 'utf8'); } /** * Creates a contract from a plain object * @static * @param {object} object - Dictionary of contract data * @returns {Contract} */ static fromObject(object) { return new Contract(object); } /** * Creates a contract from a JSON string * @param {string} json - JSON encoded contract * @returns {Contract} */ static fromJSON(json) { return new Contract(JSON.parse(json)); } /** * Creates a contract from a Buffer * @param {buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ static fromBuffer(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); } /** * Infers the type of object supplied and constructs a contract * @param {object|string|buffer} data * @returns {Contract} */ static from(data) { if (data instanceof Contract) { return Contract.fromObject(data.toObject()); } else if (Buffer.isBuffer(data)) { return Contract.fromBuffer(data); } else if (typeof data === 'string') { return Contract.fromJSON(data); } else { return Contract.fromObject(data); } } /** * Create a topical OPCODE byte sequence from the provided criteria * @param {object} criteria * @param {number} criteria.size - Criteria degree OPCODE * @param {number} criteria.duration - Criteria degree OPCODE * @param {number} criteria.availability - Criteria degree OPCODE * @param {number} criteria.speed - Criteria degree OPCODE * @returns {buffer} */ static createTopic(criteria) { criteria = merge(Contract.CRITERIA, criteria); return new Buffer([ constants.OPCODE_CONTRACT_PREFIX, criteria.size, criteria.duration, criteria.availability, criteria.speed ]); } /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {boolean} */ static compare(c1, c2) { const contract1 = c1.toObject(); const contract2 = c2.toObject(); const ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); } /** * Returns the property names between two contracts that differ * @param {Contract} c1 - Contract to compare * @param {contract} c2 - Contract to compare * @returns {string[]} changedProperties */ static diff(c1, c2) { const differs = []; c1 = c1.toObject(); c2 = c2.toObject(); for (let prop in c1) { if (Array.isArray(c1[prop])) { if (JSON.stringify(c1[prop]) !== JSON.stringify(c2[prop])) { differs.push(prop); } } else if (c1[prop] !== c2[prop]) { differs.push(prop); } } return differs; } } module.exports = Contract; × Search results Close "},"lib_profiles.js.html":{"id":"lib_profiles.js.html","title":"Source: lib/profiles.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/profiles.js /** * @module orc/profiles */ 'use strict'; const async = require('async'); const ms = require('ms'); const bytes = require('bytes'); const Contract = require('./contract'); const Audit = require('./audit'); const Proof = require('./proof'); const Bridge = require('./bridge'); const constants = require('./constants'); const utils = require('./utils'); const Zcash = require('zcash'); const tiny = require('tiny'); /** * Base class for a profile, sets up zcash wallet and other shared profile * behavior */ class Profile { /** * @constructor * @param {Node} node * @param {object} config */ constructor(node, config) { this.node = node; this.config = config; this.wallet = this._createWallet(); this._init(); } /** * Generates a new zcash address * @param {Profile~getNewAddressCallback} callback */ getNewAddress(callback) { if (parseInt(this.config.WalletShieldedTransactions)) { this.wallet.z_getnewaddress() .then((addr) =&gt; callback(null, addr), callback); } else { this.wallet.getnewaddress() .then((addr) =&gt; callback(null, addr), callback); } } /** * @callback Profile~getNewAddressCallback * @param {error|null} error * @param {string} address */ /** * Creates a zcash wallet instance * @private */ _createWallet() { return new Zcash({ username: this.config.WalletUser, password: this.config.WalletPassword, port: parseInt(this.config.WalletPort), host: this.config.WalletHostname }); } /** * Initializes the profile * @private */ _init() {} } /** * Applies the farmer profile to the supplied node. A farmer publishes capacity * announcements, subscribes to contract publications, and reaps stale shards. */ class FarmerProfile extends Profile { /** * @constructor * @param {Node} node * @param {object} config */ constructor(node, config) { super(node, config); } /** * @private */ _init() { this.node.logger.info( `subscribing to ${this.config.FarmerAdvertiseTopics.length} topic codes` ); this.node.subscribeShardDescriptor( this.config.FarmerAdvertiseTopics, (err, rs) =&gt; { if (err) { this.node.logger.warn(err.message); } else { rs.on('data', (data) =&gt; this._handleContract(...data)); } } ); this.announceCapacity(); setInterval(() =&gt; this.announceCapacity(), ms(this.config.FarmerAnnounceInterval)); setInterval(() =&gt; this.reapExpiredShards(), ms(this.config.FarmerShardReaperInterval)); } /** * Handles incoming contract publications and sends storage offer * @private * @param {object} contract * @param {array} contact */ _handleContract(contract, contact) { contract = Contract.from(contract); this.getNewAddress((err, addr) =&gt; { if (err) { this.node.logger.error(err.message); return this.node.logger.warn( 'cannot send offer for shard, failed to get new address from wallet' ); } contract.set('farmer_id', this.node.identity.toString('hex')); contract.set('farmer_hd_key', this.node.contact.xpub); contract.set('farmer_hd_index', this.node.contact.index); contract.set('payment_destination', addr); contract.sign('farmer', this.node.spartacus.privateKey); contract = contract.toObject(); this.node.offerShardAllocation(contact, contract, (err) =&gt; { if (err) { this.node.logger.info(`offer rejected, reason: ${err.message}`); } else { this.node.logger.info( `acquired storage contract ${contract.data_hash} ` + `from renter node ${contact[0]}` ); } }); }); } /** * Announces current storage capacity to neighbors * @param {FarmerProfile~announceCapacityCallback} callback */ announceCapacity(callback = () =&gt; null) { this.node.shards.size((err, data) =&gt; { if (err) { return this.node.logger.warn('failed to measure capacity'); } async.eachSeries(this.config.FarmerAdvertiseTopics, (topic, next) =&gt; { this.node.publishCapacityAnnouncement(topic, data, (err) =&gt; { if (err) { this.node.logger.error(err.message); this.node.logger.warn('failed to publish capacity announcement'); } else { this.node.logger.info('published capacity announcement ' + `${data.available}/${data.allocated}` ); } next(); }); }, callback); }); } /** * @callback FarmerProfile~announceCapacityCallback * @param {error|null} error */ /** * Scans the contract database for expired shards and reaps them from storage * @param {FarmerProfile~reapExpiredShardsCallback} callback */ reapExpiredShards(callback = () =&gt; null) { const time = Date.now(); const rs = this.node.contracts.createReadStream(); this.node.logger.info('starting contract database scan for stale shards'); rs.on('data', ({ key, value }) =&gt; { let contract = Contract.from(value); if (contract.get('end_time') &lt; (time + ms('24h'))) { this.node.shards.unlink(contract.get('data_hash'), (err) =&gt; { if (err) { this.node.logger.warn(`failed to reap shard ${value.data_hash}`); } else { this.node.logger.info(`unlinked stale shard ${value.data_hash}`); this.node.contracts.del(key, () =&gt; rs.resume()); } }); } else { rs.resume(); } }); rs.on('end', () =&gt; { this.node.logger.info('finished reaping stale shards'); callback(null); }); rs.on('error', (err) =&gt; { this.node.logger.error(err.message); this.node.logger.warn('did not complete reaping stale shards'); callback(err); }); } /** * @callback FarmerProfile~reapExpiredShardsCallback * @param {error|null} error */ } /** * Applies the renter profile to the supplied node. A renter listens for * capacity announcements and keeps a cache, exposes a local bridge for * upload/download, handles auditing, mirroring, and payments. */ class RenterProfile extends Profile { /** * @constructor * @param {Node} node * @param {object} config */ constructor(node, config) { super(node, config); this.capacity = tiny(config.RenterCapacityCachePath); } /** * Exposes the capacity cache over the control port * @param {RenterProfile~getCapacityCacheCallback} callback */ getCapacityCache(callback) { this.capacity.find({})(callback); } /** * @private */ _init() { this.node.logger.info('subscribing to network capacity announcements'); this.node.subscribeCapacityAnnouncement( this.config.RenterListenTopics, (err, rs) =&gt; { rs.on('data', ([available, contact]) =&gt; { let timestamp = Date.now(); this.capacity.set(contact[0], { available, contact, timestamp }); }); } ); if (!parseInt(this.config.BridgeEnabled)) { return; } let opts = { store: this.config.BridgeMetaStoragePath, stage: this.config.BridgeTempStagingBaseDir, auditInterval: ms(this.config.BridgeShardAuditInterval), capacityCache: this.capacity }; if (parseInt(this.config.BridgeAuthenticationEnabled)) { opts.auth = { user: this.config.BridgeAuthenticationUser, pass: this.config.BridgeAuthenticationPassword }; } this.bridge = new Bridge(opts); this.node.logger.info( 'establishing local bridge at ' + `${this.config.BridgeHostname}:${this.config.BridgePort}` ); this.bridge.listen(parseInt(this.config.BridgePort), this.config.BridgeHostname); } } /** * Applies the farmer profile * @function * @param {Node} node * @param {object} config * @returns {FarmerProfile} */ module.exports.farmer = function(node, config) { node.profiles = node.profiles || {}; node.profiles.farmer = new FarmerProfile(node, config); return node.profiles.farmer; }; /** * Applies the renter profile * @function * @param {Node} node * @param {object} config * @returns {RenterProfile} */ module.exports.renter = function(node, config) { node.profiles = node.profiles || {}; node.profiles.renter = new RenterProfile(node, config); return node.profiles.renter; }; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: index.js /** * @module orc * @license AGPL-3.0 */ 'use strict'; const { spawn } = require('child_process'); const { join } = require('path'); /** * Forks a child orc process and returns the child process and a controller * client for sending commands to it * @function * @param {object|string} config - Configuration properties as object or path * to a configuration file. See {@tutorial config} for details. * connect to the control port * @returns {object} */ /* istanbul ignore next */ module.exports = function(config = {}) { /* eslint max-statements: [2, 18] */ const cport = config.ControlPort || require('./bin/_config').ControlPort; const caddr = config.ControlPort || require('./bin/_config').ControlHostname; const controller = new module.exports.control.Client(); let envs = {}; let args = [join(__dirname, './bin/orc.js')]; let trys = 10; let opts = { env: envs }; if (typeof config === 'string') { args = args.concat(['--config', config]); } else { for (let prop in config) { envs[`orc_${prop}`] = config[prop]; } } const child = spawn(process.execPath, args, opts); function connect() { controller.once('error', () =&gt; { controller.removeAllListeners(); if (trys !== 0) { trys--; setTimeout(connect, 1000); } }); controller.on('ready', () =&gt; controller.removeAllListeners('error')); controller.connect(cport, caddr); } process.on('exit', () =&gt; child.kill()); child.stdout.once('data', () =&gt; setTimeout(() =&gt; connect(), 1000)); child.stderr.once('data', (msg) =&gt; child.emit('error', new Error(msg))); return { child, controller }; }; /** {@link Node} */ module.exports.Node = require('./lib/node'); /** {@link Rules} */ module.exports.Rules = require('./lib/rules'); /** {@link Transport} */ module.exports.Transport = require('./lib/transport'); /** {@link Server} */ module.exports.Server = require('./lib/server'); /** {@link Audit} */ module.exports.Audit = require('./lib/audit'); /** {@link Proof} */ module.exports.Proof = require('./lib/proof'); /** {@link Offers} */ module.exports.Offers = require('./lib/offers'); /** {@link Shards} */ module.exports.Shards = require('./lib/shards'); /** {@link Contract} */ module.exports.Contract = require('./lib/contract'); /** {@link Bridge} */ module.exports.Bridge = require('./lib/bridge'); /** {@link module:orc/constants} */ module.exports.constants = require('./lib/constants'); /** {@link module:orc/profiles} */ module.exports.profiles = require('./lib/profiles'); /** {@link module:orc/utils} */ module.exports.utils = require('./lib/utils'); /** {@link module:orc/version} */ module.exports.version = require('./lib/version'); /** @see https://github.com/bookchin/boscar */ module.exports.control = require('boscar'); × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/constants.js /** * @module orc/constants */ 'use strict'; module.exports = { /** * @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** * @constant {Number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 86400000, /** * @constant {Number} CONSIGN_THRESHOLD - Threshold for consign time */ CONSIGN_THRESHOLD: 86400000, /** * @constant {Number} TOKEN_EXPIRE - Reject datachannl token after time */ TOKEN_EXPIRE: 1800000, /** * @constant {Number} OFFER_TIMEOUT - Max wait time for storage offer */ OFFER_TIMEOUT: 15000, /** * @constant {Number} OPCODE_CONTRACT_PREFIX - Prefix opcode for contracts */ OPCODE_CONTRACT_PREFIX: 0x0f, /** * @constant {Number} OPCODE_DEG_NULL - Opcode for null criteria degree */ OPCODE_DEG_NULL: 0x00, /** * @constant {Number} OPCODE_DEG_LOW - Opcode for low criteria degree */ OPCODE_DEG_LOW: 0x01, /** * @constant {Number} OPCODE_DEG_MED - Opcode for medium criteria degree */ OPCODE_DEG_MED: 0x02, /** * @constant {Number} OPCODE_DEG_HIGH - Opcode for medium criteria degree */ OPCODE_DEG_HIGH: 0x03, /** * @constant {Number} MAX_CONCURRENT_OFFERS - Number of concurrent offers */ MAX_CONCURRENT_OFFERS: 3, /** * @constant {Number} MAX_CONCURRENT_AUDITS - Number of concurrent audits */ MAX_CONCURRENT_AUDITS: 3, /** * @constant MAX_NODE_INDEX - Maximum node index */ MAX_NODE_INDEX: 0x7fffffff, /** * @constant HD_KEY_DERIVATION_PATH - Key derivation path for HD keys */ HD_KEY_DERIVATION_PATH: 'm/3000\\'/0\\'' }; × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/utils.js /** * @module orc/utils */ 'use strict'; const https = require('https'); const stream = require('stream'); const assert = require('assert'); const secp256k1 = require('secp256k1'); const HDKey = require('hdkey'); const constants = require('./constants'); const crypto = require('crypto'); const semver = require('semver'); const ip = require('ip'); /** * Returns the SHA-256 hash of the input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.sha256 = function(input, encoding) { return crypto.createHash('sha256').update(input, encoding).digest(); }; /** * Returns the RIPEMD-160 hash of the input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.rmd160 = function(input, encoding) { return crypto.createHash('rmd160').update(input, encoding).digest(); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {string|buffer} input - Data to hash * @param {string} encoding - The encoding type of the data * @returns {buffer} */ module.exports.rmd160sha256 = function(input, encoding) { return module.exports.rmd160(module.exports.sha256(input, encoding)); }; /** * Returns the next power of two number * @param {number} number * @returns {number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Returns a stringified URL from the supplied contact object * @param {array} contact * @param {string} contact.0 - Node identity key * @param {object} contact.1 * @param {string} contact.1.hostname * @param {string} contact.1.port * @param {string} contact.1.protocol * @returns {string} */ module.exports.getContactURL = function(contact) { const [identity, info] = contact; return `${info.protocol}//${info.hostname}:${info.port}/${identity}`; }; /** * Returns whether or not the supplied semver tag is compatible * @param {string} version - The semver tag from the contact * @returns {boolean} */ module.exports.isCompatibleVersion = function(version) { const local = require('./version').protocol; const remote = version; const sameMajor = semver.major(local) === semver.major(remote); const diffs = ['prerelease', 'prepatch', 'preminor', 'premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else { return sameMajor; } }; /** * Determines if the supplied contact is valid * @param {array} contact - The contact information for a given peer * @param {boolean} loopback - Allows contacts that are localhost * @returns {boolean} */ module.exports.isValidContact = function(contact, loopback) { const [, info] = contact; const isValidAddr = ip.isV4Format(info.hostname) || ip.isV6Format(info.hostname) || ip.isPublic(info.hostname); const isValidPort = info.port &gt; 0; const isAllowedAddr = ip.isLoopback(info.hostname) ? !!loopback : true; return isValidPort &amp;&amp; isValidAddr &amp;&amp; isAllowedAddr; }; /** * Determines if a value is hexadecimal string * @param {*} a - The value to be tested * @returns {boolean} */ module.exports.isHexaString = function(a) { if (typeof a !== 'string') { return false; } return /^[0-9a-fA-F]+$/.test(a); }; /** * Checks if the supplied HD key is valid (base58 encoded) and proper length * @param {string} hdKey - The HD key in base 58 encoding * @returns {boolean} isValidHDKey */ module.exports.isValidHDNodeKey = function(hdKey) { return typeof hdKey === 'string' &amp;&amp; /^[1-9a-km-zA-HJ-NP-Z]{1,111}$/.test(hdKey); }; /** * Checks if the input is a non-hardened HD key index * @param {number} hdIndex - The HD key index * @returns {boolean} isValidHDKeyIndex */ module.exports.isValidNodeIndex = function(n) { return !Number.isNaN(n) &amp;&amp; (parseInt(n) === n) &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= constants.MAX_NODE_INDEX; }; /** * Returns a HD key object using corrent key derivation path using the * given seed * @param {buffer} seed64 - 64 byte seed for generating key * @returns {HDKey} */ module.exports.createComplexKeyFromSeed = function(seed64) { assert(Buffer.isBuffer(seed64), 'Seed must be a buffer'); assert(seed64.length === 64, 'Seed must be 64 bytes in length'); var hdKey = HDKey.fromMasterSeed(seed64).derive( constants.HD_KEY_DERIVATION_PATH ); return hdKey.privateExtendedKey; }; /** * Returns a request object for uploading a shard to a farmer * @param {array} farmer - Farmer contact object * @param {string} hash - The hash of the shard to upload * @param {string} token - The authorized transfer token * @returns {https.ClientRequest} */ module.exports.createShardUploader = function(farmer, hash, token) { const [, contact] = farmer; function _createUploadStream() { return https.request({ method: 'POST', rejectUnauthorized: false, protocol: contact.protocol, hostname: contact.hostname, port: contact.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream' } }); } return new stream.Transform({ transform: function(chunk, encoding, callback) { /* istanbul ignore else */ if (!this._uploader) { this._uploader = _createUploadStream(); this._uploader.on('response', this.emit.bind(this, 'response')); this._uploader.on('error', (err) =&gt; { this.unpipe(); this.emit('error', err); }); } this._uploader.write(chunk, encoding, callback); }, flush: function(callback) { /* istanbul ignore else */ if (this._uploader) { this._uploader.end(); } callback(); } }); }; /** * Returns a request object for downloading a shard from a farmer * @param {array} farmer - Farmer contact object * @param {string} hash - The hash of the shard to upload * @param {string} token - The authorized transfer token * @returns {https.ClientRequest} */ module.exports.createShardDownloader = function(farmer, hash, token) { const [, contact] = farmer; function _createDownloadStream() { return https.get({ rejectUnauthorized: false, protocol: contact.protocol, hostname: contact.hostname, port: contact.port, path: `/shards/${hash}?token=${token}`, headers: { 'content-type': 'application/octet-stream' } }); } return new stream.Readable({ read: function() { if (!this._downloader) { this._downloader = _createDownloadStream(); this._downloader.on('response', (res) =&gt; { res .on('data', this.push.bind(this)) .on('error', this.emit.bind(this, 'error')) .on('end', this.push.bind(this, null)); }) .on('error', this.emit.bind(this, 'error')); } } }); }; /** * Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret * derived from the given public and private keys * @param {buffer} publicKey - SECP256k1 public key bytes * @param {buffer} privateKey - SECP256k1 private key bytes * @returns {object} */ module.exports.createCipher = function(publicKey, privateKey) { const secret = secp256k1.ecdh(publicKey, privateKey); const cipher = crypto.createCipher('aes-256-cbc-hmac-sha256', secret); return cipher; }; /** * Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret * derived from the given public and private keys * @param {buffer} publicKey - SECP256k1 public key bytes * @param {buffer} privateKey - SECP256k1 private key bytes * @returns {object} */ module.exports.createDecipher = function(publicKey, privateKey) { const secret = secp256k1.ecdh(publicKey, privateKey); const decipher = crypto.createDecipher('aes-256-cbc-hmac-sha256', secret); return decipher; }; /** * Returns the appropriate shard size, number of shards, and number of parity * shards for RS encoding/decoding provided the total number of bytes of the * complete content * @param {number} n - Number of bytes in data * @returns {object} */ module.exports.getErasureParameters = function(n) { let size = 8 * (1024 * 1024); let params = { shards: 2, parity: 1, length: n, get size() { return params.length / params.shards; } }; function accumulate() { if (n &gt; size &amp;&amp; params.shards !== 16 &amp;&amp; params.parity !== 8) { size = size * 4; params.shards = params.shards * 2; params.parity = params.parity * 2; return accumulate(); } else { return params; } } return accumulate(); }; × Search results Close "},"lib_version.js.html":{"id":"lib_version.js.html","title":"Source: lib/version.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/version.js /** * @module orc/version */ 'use strict'; var semver = require('semver'); var assert = require('assert'); var postfix = process.env.ORC_NETWORK ? `-${process.env.ORC_NETWORK}` : ''; module.exports = { /** * @constant {string} protocol - The supported protocol version */ protocol: '2.0.0' + postfix, /** * @constant {string} software - The current software version */ software: require('../package').version, /** * Returns human readable string of versions * @function * @returns {string} */ toString: function() { let { software, protocol } = module.exports; return `orc v${software} protocol v${protocol}`; } }; assert( semver.valid(module.exports.protocol), 'Invalid protocol version specified' ); × Search results Close "},"lib_node.js.html":{"id":"lib_node.js.html","title":"Source: lib/node.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/node.js 'use strict'; const url = require('url'); const { Readable: ReadableStream } = require('stream'); const { createLogger } = require('bunyan'); const merge = require('merge'); const { KademliaNode } = require('kad'); const quasar = require('kad-quasar'); const spartacus = require('kad-spartacus'); const constants = require('./constants'); const https = require('https'); const Contract = require('./contract'); const OfferStream = require('./offers'); const Rules = require('./rules'); const Server = require('./server'); const Transport = require('./transport'); /** * Extends Kademlia with Orc protocol rules * @license AGPL-3.0 */ class Node extends KademliaNode { static get DEFAULTS() { return { logger: createLogger({ name: 'storj' }), transport: new Transport(), privateExtendedKey: null, keyDerivationIndex: 1, contracts: null, shards: null, claims: [] }; } /** * @constructor * @extends {KademliaNode} * @param {object} options * @param {string} options.privateExtendedKey - HD extended private key * @param {object} [options.logger] - Bunyan compatible logger * @param {object} [options.transport] - Orc transport adapter * @param {object} options.contracts - Levelup compatible contract store * @param {object} options.shards - KFS compatible shard database * @param {string[]} [options.claims] - Enable direct capacity claims from * the given public extended keys * @param {number} [options.keyDerivationIndex] - HD derivation index */ constructor(options) { const opts = merge(Node.DEFAULTS, options); super(merge(Node.DEFAULTS, options)); this.quasar = this.plugin(quasar); this.spartacus = this.plugin(spartacus(options.privateExtendedKey, options.keyDerivationIndex, constants.HD_KEY_DERIVATION_PATH)); this.offers = new Map(); this.contracts = opts.contracts; this.shards = opts.shards; this.server = new Server({ contracts: this.contracts, shards: this.shards, identity: this.identity }); this.claims = opts.claims; this.transport.on('identify', (req, res) =&gt; { this.logger.debug('responding to peer requested identification'); res.end(JSON.stringify([ this.identity.toString('hex'), this.contact ])); }); this.transport.on('download', (req, res) =&gt; { this.logger.debug('handling shard download request'); this.server.download(req, res) }); this.transport.on('upload', (req, res) =&gt; { this.logger.debug('handling shard upload request'); this.server.upload(req, res) }); } /** * Adds the kademlia rule handlers before calling super#listen() */ listen() { let handlers = new Rules(this); this.use('OFFER', handlers.offer.bind(handlers)); this.use('AUDIT', handlers.audit.bind(handlers)); this.use('CONSIGN', handlers.consign.bind(handlers)); this.use('MIRROR', handlers.mirror.bind(handlers)); this.use('RETRIEVE', handlers.retrieve.bind(handlers)); this.use('PROBE', handlers.probe.bind(handlers)); this.use('RENEW', handlers.renew.bind(handlers)); this.use('CLAIM', handlers.claim.bind(handlers)); super.listen(...arguments); } /** * Sends a GET request to the URI and parses the result as a valid * contact object with identity * @param {string} url - The URL of the node * @param {Node~identifyServiceCallback} callback */ identifyService(uri, callback) { const options = merge(url.parse(uri), { agent: this.onion.createSecureAgent(), method: 'GET' }); const req = https.request(options, (res) =&gt; { let body = ''; res.on('error', callback); res.on('data', (data) =&gt; body += data.toString()); res.on('end', () =&gt; { if (res.statusCode !== 200) { callback(new Error(body)); } else { try { callback(null, JSON.parse(body)); } catch (err) { callback(new Error('Failed to parse identity')); } } }); }); req.on('error', callback); req.end(); } /** * @callback Node~identifyServiceCallback * @param {error|null} error * @param {array} contact */ /** * Requests authorization tokens to pull file shard(s) from another node * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {string[]} hashes - Hashes of the shards to pull * @param {Node~authorizeRetrievalCallback} callback */ authorizeRetrieval(peer, hashes, callback) { this.send('RETRIEVE', hashes, peer, callback); } /** * @callback Node~authorizeRetrievalCallback * @param {error|null} error * @param {string[]} retrievalTokens */ /** * Requests authorization tokens to push file shard(s) to another node * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {string[]} hashes - Hashes of the shards to push * @param {Node~authorizeConsignmentCallback} callback */ authorizeConsignment(peer, hashes, callback) { this.send('CONSIGN', hashes, peer, callback); } /** * @callback Node~authorizeConsignmentCallback * @param {error|null} error * @param {string[]} consignmentTokens */ /** * Requests the source node to MIRROR a shard to the supplied destination * @param {array} source * @param {string} source.0 - Identity key string * @param {string|object} source.1 - Address data for contact * @param {object} target * @param {array} target.destination - * @param {string} target.destination.0 - Identity key string * @param {string|object} target.destination.1 - Address data for contact * @param {string} target.hash - Hash of the shard to mirror * @param {string} target.token - Authorization token to PUSH shard * @param {Node~createShardMirrorCallback} callback */ createShardMirror(source, target, callback) { this.send('MIRROR', [target.hash, target.token, target.destination], source, callback); } /** * @callback Node~createShardMirrorCallback * @param {object|null} error */ /** * Sends the series of hash/challenge pairs to the remote node to request * proof-of-storage * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object[]} audits * @param {string} audits.hash - Hash of the shard to prove * @param {string} audits.challenge - Challenge string to prepend to shard * @param {Node~auditRemoteShardsCallback} callback */ auditRemoteShards(peer, audits, callback) { this.send('AUDIT', audits, peer, callback); } /** * @callback Node~auditRemoteShardsCallback * @param {object|null} error * @param {object[]} proofs * @param {string} proofs.hash - Hash of the shard for corresponding proof * @param {string} proofs.proof - {@tutorial compact-merkle-proof} */ /** * Publishes a storage contract proposal to the network and exposes a stream * of received OFFER messages * @param {object} contract - See {@tutorial storage-contracts} for format * @param {object} [offerStreamOptions] - See {@link OfferStream} * @param {Node~publishShardDescriptorCallback} callback */ publishShardDescriptor(contract, options, callback) { contract = Contract.from(contract); /* istanbul ignore else */ if (typeof options === 'function') { callback = options; options = {}; } const routingKey = contract.get('data_hash'); const topicString = contract.getTopicString(); const offerStream = new OfferStream(contract, options); const descriptor = contract.toObject(); const contents = [ descriptor, [this.identity.toString('hex'), this.contact] ]; ['end', 'error', 'destroy'].forEach((event) =&gt; { offerStream.on(event, () =&gt; this.offers.delete(routingKey)); }); this.offers.set(routingKey, offerStream); this.quasarPublish(topicString, contents, { routingKey }, (err) =&gt; { if (err) { return callback(err); } callback(null, offerStream); }); } /** * @callback Node~publishShardDescriptorCallback * @param {error|null} error * @param {Offers} offerStream - Readable stream of OFFER messages */ /** * Resolves the offer for the given shard hash and offer identifier * @param {string} hash - Shard hash for the contract * @param {string} offer - Unique offer identifier * @param {error|null} error - If applicable an error object * @param {object|null} contract - The resolved and signed contract * @param {Node~resolveContractOfferCallback} callback */ /* eslint max-params: [2, 5] */ resolveContractOffer(hash, offer, error, contract, callback) { const stream = this.offers.get(hash); const resolver = stream ? stream.resolvers.get(offer) : null; if (!resolver) { return callback(new Error('Offer resolver not found')); } resolver(error, contract); callback(null); } /** * @callback Node~resolveContractOfferCallback * @param {error|null} error */ /** * Subscribes to the supplied shard descriptor topics and executes the user * and exposes a stream of incoming shard descriptor messages * @param {string[]} descriptorCodes - See {@tutorial protocol} * @param {Node~subscribeShardDescriptorCallback} callback */ subscribeShardDescriptor(descriptorCodes, callback) { const descriptorStream = new ReadableStream({ read: () =&gt; null, objectMode: true }); descriptorCodes = descriptorCodes.map((code) =&gt; `0f${code}`); this.quasarSubscribe(descriptorCodes, ([descriptor, contact]) =&gt; { descriptor = Contract.from(descriptor); if (descriptor.isValid()) { descriptorStream.push([descriptor.toObject(), contact]); } }); callback(null, descriptorStream); } /** * @callback Node~subscribeShardDescriptorCallback * @param {error|null} error * @param {ReadableStream} descriptorStream - Readable stream of incoming * shard descriptors */ /** * Offers a peer an allocation for the storage of a given shard * descriptor-turned-contract, see {@tutorial storage-contracts} for details * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object} contract - The completed shard descriptor contract * @param {Node~offerShardAllocationCallback} callback */ offerShardAllocation(peer, descriptor, callback) { this.send('OFFER', [descriptor], peer, (err, result) =&gt; { if (err) { return callback(err); } const contract = Contract.from(result[0]); const hash = contract.get('data_hash'); const [, { xpub }] = peer; const key = `${hash}:${xpub}`; if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return callback(new Error( 'Peer replied with invalid or incomplete contract' )); } this.contracts.put(key, result[0], (err) =&gt; callback(err, contract)); }); } /** * @callback Node~offerShardAllocationCallback * @param {error|null} error * @param {object} contract - See {@tutorial storage-contracts} */ /** * Requests that the target peer update their local version of the given * contract. Used to extend storage time or terminate storage. Peer will * respond with an error or their updated, signed record of the renewal. * @param {array} peer * @param {string} peer.0 - Identity key string * @param {object} peer.1 - Address data for contact * @param {object} contract - The completed shard descriptor contract * @param {Node~requestContractRenewalCallback} callback */ requestContractRenewal(peer, descriptor, callback) { this.send('RENEW', [descriptor], peer, (err, result) =&gt; { if (err) { return callback(err); } const contract = Contract.from(result[0]); const hash = contract.get('data_hash'); const [, { xpub }] = peer; const key = `${hash}:${xpub}`; if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return callback(new Error( 'Peer replied with invalid or incomplete contract' )); } this.contracts.put(key, result, (err) =&gt; callback(err, contract)); }); } /** * @callback Node~requestContractRenewalCallback * @param {error|null} error * @param {object} contract - See {@tutorial storage-contracts} */ /** * Subscribes to capacity announcements for the given topic codes * and exposes announcements as a stream. * @param {string[]} descriptorCodes - See {@tutorial protocol} * @param {Node~subscribeCapacityAnnouncementCallback} callback */ subscribeCapacityAnnouncement(descriptorCodes, callback) { const capacityStream = new ReadableStream({ read: () =&gt; null, objectMode: true }); descriptorCodes = descriptorCodes.map((code) =&gt; `0c${code}`); this.quasarSubscribe(descriptorCodes, ([bytesAvailable, contact]) =&gt; { capacityStream.push([bytesAvailable, contact]); }); callback(null, capacityStream); } /** * @callback Node~subscribeCapacityAnnouncementCallback * @param {error|null} error * @param {ReadableStream} capacityStream */ /** * Announces to interested renter nodes that this node has capacity * available for renting. * @param {string[]} descriptorCode - See {@tutorial protocol} * @param {number} bytesAvailable - Total bytes capacity available * @param {Node~publishCapacityAnnouncementCallback} callback */ publishCapacityAnnouncement(descriptorCode, bytesAvailable, callback) { const contents = [ bytesAvailable, [this.identity.toString('hex'), this.contact] ]; this.claims = bytesAvailable &gt; 0 ? this.claims : []; this.quasarPublish(`0c${descriptorCode}`, contents, callback); } /** * @callback Node~publishCapacityAnnouncementCallback * @param {error|null} error */ /** * Claims capacity from a farming node, given a valid contract * @param {array} peer * @param {string} peer.0 - Identity key string * @param {string|object} peer.1 - Address data for contact * @param {object} descriptor - Contract descriptor * @param {Node~claimFarmerCapacityCallback} callback */ claimFarmerCapacity(peer, descriptor, callback) { this.send('CLAIM', [descriptor], peer, callback); } /** * @callback Node~claimFarmerCapacityCallback * @param {error|null} error * @param {array} result * @param {object} result.0 - Completed contract result * @param {string} result.1 - Consignment token */ } module.exports = Node; × Search results Close "},"lib_offers.js.html":{"id":"lib_offers.js.html","title":"Source: lib/offers.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/offers.js 'use strict'; const { Readable: ReadableStream } = require('stream'); const merge = require('merge'); const { v4: uuid } = require('uuid'); /** * Manages a stream of offers for a given storage contract publication */ class Offers extends ReadableStream { static get DEFAULTS() { return { maxOffers: 12, farmerBlacklist: [] }; } /** * @constructor * @param {Contract} contract - Storage contract published to network * @param {Object} [options] * @param {Number} [options.maxOffers] - Maximum number of offers to process * @param {Array.&lt;String&gt;} [options.farmerBlacklist] - Reject offers from nodeID */ constructor(contract, options) { super({ objectMode: true }); this.options = merge(Offers.DEFAULTS, options); this.resolvers = new Map(); this._contract = contract; this._queue = []; this._offersQueued = 0; this._offersProccessed = 0; this._farmersDidOffer = []; this._isDestroyed = false; } /** * Triggered when an offer is received * @event Offers#data * @param {Object} data * @param {Contact} data.contact - The sending farmer for the offer * @param {Contract} data.contract - The received offer contract */ /** * Triggered when the maximum number of offers are received and processed * @event Offers#end */ /** * Triggered if an error occurs * @event Offers#error * @param {Error} error - The error object with message */ /** * Implements the underlying stream * @private */ _read() { if (this._offersProccessed === this.options.maxOffers) { return this.push(null); } const _push = () =&gt; { this._offersProccessed++; this.push(this._queue.shift()); } if (this._queue.length &gt; 0) { return setImmediate(_push); } this.once('_offerAddedToQueue', _push); } /** * Adds the offer to the internal queue if there is room * @param {array} contact - The sending farmer for the offer * @param {object} contract - The received offer contract * @param {function} callback */ queue(contact, contract, callback) { const self = this; const isDestroyed = this._isDestroyed; const farmerSentOffer = this._farmersDidOffer.indexOf(contact[0]) !== -1; const contractIncomplete = !contract.isComplete(); const maxReached = this._offersQueued === this.options.maxOffers; const id = uuid(); if (isDestroyed || farmerSentOffer || contractIncomplete || maxReached) { return callback(new Error('Storage offer rejected')); } this.resolvers.set(id, function() { callback(...arguments); self.resolvers.delete(id); }); this._farmersDidOffer.push(contact[0]); this._queue.push({ contact: contact, contract: contract.toObject(), id }); this._offersQueued++; this.emit('_offerAddedToQueue'); } /** * Tears down listeners and ends the stream */ destroy() { this._queue = []; this._isDestroyed = true; setImmediate(this.removeAllListeners.bind(this)); this.emit('destroy'); } } module.exports = Offers; × Search results Close "},"lib_proof.js.html":{"id":"lib_proof.js.html","title":"Source: lib/proof.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/proof.js 'use strict'; const { Transform: TransformStream } = require('stream'); const assert = require('assert'); const MerkleTree = require('mtree'); const crypto = require('crypto'); const utils = require('./utils'); /** * Provides interface for proving possession of a file for an * {@link AuditStream} */ class Proof extends TransformStream { /** * Verifies the proof given the merkle root and tree depth * @static * @memberof Proof * @param {*} proof - Compact proof result * @param {string} root - Merkle tree root from audit leaves * @param {number} depth - Depth of the merkle tree * @returns {string[]} */ static verify(proof, root, depth) { function _getChallengeResponse(tuple) { let data = tuple || proof; if (data.length === 1) { return utils.rmd160sha256(data[0], 'hex'); } if (Array.isArray(data[0])) { return _getChallengeResponse(data[0]); } else { return _getChallengeResponse(data[1]); } } function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); const proofhash = utils.rmd160sha256(proof[0], 'hex'); assert(Buffer.compare(proofhash, leaf) === 0, 'Invalid proof value'); return leaf; } let hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256(Buffer.concat([ Buffer.from(hashL, 'hex'), Buffer.from(hashR, 'hex') ])); } return [ _collapse(proof, _getChallengeResponse(), depth - 1), root ]; } /** * @constructor * @param {string[]} merkleLeaves - Bottom leaves of the audit merkle tree * @param {string|buffer} hexChallenge - The challenge data in hex to prepend * to shard */ constructor(leaves, challenge) { super({ objectMode: true }); assert(Array.isArray(leaves), 'Merkle leaves must be an array'); assert.ok(challenge, 'Invalid challenge supplied'); this._tree = new MerkleTree(this._generateLeaves(leaves), utils.rmd160sha256); if (!Buffer.isBuffer(challenge)) { this._challenge = Buffer.from(challenge, 'hex'); } else { this._challenge = challenge; } this._hasher = crypto.createHash('sha256').update(this._challenge); this._proof = null; } /** * Returns the generated proof structure * @return {array} */ getProofResult() { assert(Array.isArray(this._proof), 'Proof generation is not complete'); return this._proof; } /** * Handles writing the shard data to the proof stream * @private */ _transform(chunk, encoding, next) { this._hasher.update(chunk, encoding); next(); } /** * Generates the proof from the read data * @private */ _flush(done) { try { this._generateProof(); } catch (err) { return done(err); } this.push(this.getProofResult()); done(); } /** * Returns the index of the associated audit leaf * @private */ _findMatchIndex(leaves, leaf) { let challengenum = -1; for (let l = 0; l &lt; leaves.length; l++) { if (Buffer.compare(leaves[l], leaf) === 0) { challengenum = l; break; } } return challengenum; } /** * Calculate audit response * @private * @param {string} challenge - Challenge string sent by auditor * @returns {string[]} result - Challenge response */ _generateProof() { const response = utils.rmd160(this._hasher.digest()); const leaves = this._tree.level(this._tree.levels() - 1); const leaf = utils.rmd160sha256(response); let challengenum = this._findMatchIndex(leaves, leaf); let branches = [response.toString('hex')]; assert(challengenum !== -1, 'Failed to generate proof'); for (let i = (this._tree.levels() - 1); i &gt; 0; i--) { let level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1].toString('hex')]; } else { branches = [level[challengenum - 1].toString('hex'), branches]; } challengenum = Math.floor(challengenum / 2); } this._proof = branches; } /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {string[]} leaves */ _generateLeaves(leaves) { const numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; const emptyLeaves = []; for (let i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.map((i) =&gt; Buffer.from(i, 'hex')).concat(emptyLeaves); } } module.exports = Proof; × Search results Close "},"lib_rules.js.html":{"id":"lib_rules.js.html","title":"Source: lib/rules.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/rules.js 'use strict'; const { randomBytes } = require('crypto'); const async = require('async'); const utils = require('./utils'); const Contract = require('./contract'); const ProofStream = require('./proof'); /** * Represents Orc protocol handlers */ class Rules { /** * Constructs a Orc rules instance in the context of a Orc node * @constructor * @param {Node} node */ constructor(node) { this.node = node; } /** * Upon receipt of an OFFER message, nodes must validate the descriptor, * then ensure that the referenced shard is awaiting allocation(s). If both * checks succeed, then the descriptor is added to the appropriate offer * processing stream. Once the descriptor is processed, we respond back to * the originator with the final copy of the contract. * @param {object} request * @param {object} response */ offer(request, response, next) { const [descriptor] = request.params; const contract = Contract.from(descriptor); const shardKey = contract.get('data_hash'); const offerStream = this.node.offers.get(shardKey); if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return next(new Error('Invalid shard descriptor')); } if (!offerStream) { return next(new Error('Offers for descriptor are closed')); } offerStream.queue(request.contact, contract, (err, result) =&gt; { if (err) { return next(err); } response.send([result]); }); } /** * Upon receipt of a AUDIT message, the node must look up the contract that * is associated with each hash-challenge pair in the payload, prepend the * challenge to the shard data, and caclulate the resulting hash, formatted * as a compact proof. See {@tutorial compact-proofs}. * @param {object} request * @param {object} response */ audit(request, response, next) { const audits = request.params; const [, { xpub }] = request.contact; if (!Array.isArray(audits)) { return next(new Error('Invalid audit batch supplied')); } async.mapSeries(audits, ({ hash, challenge }, done) =&gt; { this.node.contracts.get(`${hash}:${xpub}`, (err, desc) =&gt; { if (err) { return done(null, { hash, proof: null }); } const contract = Contract.from(desc); const auditLeaves = contract.get('audit_leaves'); const proofStream = new ProofStream(auditLeaves, challenge); proofStream.on('error', () =&gt; { proofStream.removeAllListeners('finish'); done(null, { hash, proof: null }); }); proofStream.on('finish', () =&gt; { proofStream.removeAllListeners('error'); done(null, { hash, proof: proofStream.getProofResult() }); }); this.node.shards.createReadStream(hash, (err, shardStream) =&gt; { if (err) { return done(null, { hash, proof: null }); } shardStream.pipe(proofStream); }); }); }, (err, proofs) =&gt; response.send(proofs)); } /** * Upon receipt of a CONSIGN message, the node must verify that it has a * valid storage allocation and contract for the supplied hash and identity * of the originator. If so, it must generate an authorization token which * will be checked by the shard server before accepting the transfer of the * associated shard. * @param {object} request * @param {object} response */ consign(request, response, next) { const [hash] = request.params; const { contact } = request; this.node.contracts.get(`${hash}:${contact[1].xpub}`, (err, desc) =&gt; { if (err) { return next(err); } const now = Date.now(); const contract = Contract.from(desc); const token = randomBytes(32).toString('hex'); if (now &gt; contract.get('store_end')) { return next(new Error('Contract has expired')); } this.node.server.accept(token, hash, contact); response.send([token]); }); } /** * Upon receipt of a MIRROR message, the node must verify that it is in * possesion of the shard on behalf of the identity or the message * originator. If so, given the token-hash pair, it must attempt to upload * it's copy of the shard to the target to establish a mirror. * @param {object} request * @param {object} response */ mirror(request, response, next) { const [hash, token, target] = request.params; const { contact } = request; this.node.contracts.get(`${hash}:${contact[1].xpub}`, (err) =&gt; { if (err) { return next(err); } this.node.shards.createReadStream(hash, (err, shardStream) =&gt; { if (err) { return next(err); } const uploader = utils.createShardUploader(target, hash, token); uploader.on('response', (res) =&gt; { let result = ''; res.on('data', (data) =&gt; result += data.toString()); res.on('end', () =&gt; { if (res.statusCode !== 200) { return next(new Error(result)); } response.send([result]); }); }); shardStream.pipe(uploader).once('error', next); }); }); } /** * Upon receipt of a RETRIEVE message, the node must verify that it is in * possession of the shard on behalf of the identity of the originator. * If so, it must generate an authorization token which will be checked by * the shard server before accepting the transfer of the associated shard. * @param {object} request * @param {object} response */ retrieve(request, response, next) { const [hash] = request.params; const { contact } = request; this.node.contracts.get(`${hash}:${contact[1].xpub}`, (err) =&gt; { if (err) { return next(err); } const token = randomBytes(32).toString('hex'); this.node.shards.exists(hash, (err, exists) =&gt; { if (err || !exists) { return next(err || new Error('Shard not found')); } this.node.server.accept(token, hash, contact); response.send([token]); }); }); } /** * Upon receipt of a PROBE message, the node must attempt to send a PING * message to the originator using the declared contact information. If * successful, it must respond positively, otherwise error. * @param {object} request * @param {object} response */ probe(request, response, next) { this.node.ping(request.contact, (err) =&gt; { if (err) { return next(new Error('Failed to reach probe originator')); } response.send([]); }); } /** * Upon receipt of a RENEW message, the recipient farmer must extend or * terminate it's contract based on the new terms supplied by the renter. * If the renewal descriptor is valid and complete, the farmer must store * the updated version after signing and respond back to the originator * with the version containing the updated signature. * @param {object} request * @param {object} response */ renew(request, response, next) { const [descriptor] = request.params; const renewal = Contract.from(descriptor); const hash = renewal.get('data_hash'); const [, { xpub }] = request.contact; const key = `${hash}:${xpub}`; if (!(renewal.isValid() &amp;&amp; renewal.isComplete())) { return next(new Error('Descriptor is invalid or incomplete')); } this.node.contracts.get(key, (err, desc) =&gt; { if (err) { return next(err); } const allowed = [ 'renter_id', 'renter_hd_key', 'renter_signature', 'store_begin', 'store_end', 'audit_leaves' ]; const original = Contract.from(desc); const difference = Contract.diff(original, renewal); for (let prop of difference) { if (!allowed.includes(prop)) { return next(new Error(`Rejecting renewal of ${prop}`)); } } renewal.sign('farmer', this.node.spartacus.privateKey); this.node.contracts.put(key, renewal.toObject(), (err) =&gt; { if (err) { return next(err); } response.send([renewal.toObject()]); }); }); } /** * Upon receipt of an `CLAIM` message, nodes must validate the descriptor, * then ensure that there is enough available space for the shard. If both * checks succeed, then the descriptor is signed and returned along with a * consignment token so the initiating renter can immediately upload the * data. This call is the functional inverse of `OFFER`, as it is used for a * renter to signal to a farmer that it wishes to rent capacity. These * messages are generally sent based on information collected when subscribed * to farmer capacity publications. * @param {object} request * @param {object} response */ claim(request, response, next) { const [descriptor] = request.params; const contract = Contract.from(descriptor); const xpub = contract.get('renter_hd_key'); const hash = contract.get('data_hash'); if (!this.node.claims.includes(xpub) &amp;&amp; !this.node.claims.includes('*')) { return next(new Error('Currently rejecting claims')); } contract.set('farmer_id', this.node.identity.toString('hex')); contract.set('farmer_hd_key', this.node.contact.xpub); contract.set('farmer_hd_index', this.node.contact.index); contract.sign('farmer', this.node.spartacus.privateKey); if (!(contract.isValid() &amp;&amp; contract.isComplete())) { return next(new Error('Invalid shard descriptor')); } this.node.contracts.put(`${hash}:${xpub}`, contract.toObject(), (err) =&gt; { if (err) { return next(err); } const token = randomBytes(32).toString('hex'); this.node.server.accept(token, hash, request.contact); response.send([contract.toObject(), token]); }); } } module.exports = Rules; × Search results Close "},"lib_server.js.html":{"id":"lib_server.js.html","title":"Source: lib/server.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/server.js 'use strict'; const merge = require('merge'); const async = require('async'); const assert = require('assert'); const { EventEmitter } = require('events'); const crypto = require('crypto'); const utils = require('./utils'); const Contract = require('./contract'); /** * Creates a shard server for sending and receiving consigned file shards */ class Server extends EventEmitter { static get DEFAULTS() { return { tokenTtl: 1800000 }; }; /** * @constructor * @license AGPL-3.0 * @param {object} options * @param {string} options.identity - Node identity key * @param {object} options.contracts - Contract database * @param {object} options.shards - KFS shard database * @param {number} [options.tokenTtl=1800000] - Expire unused token */ constructor(options) { super(); options = merge(Server.DEFAULTS, options); this.identity = options.identity; this.shards = options.shards; this.contracts = options.contracts; this._allowed = new Map(); this._ttl = options.tokenTtl; setInterval(() =&gt; this._reapExpiredTokens(), this._ttl); } /** * Triggered when a shard has finished uploading to this instance * @event Server#shardUploaded * @param {string} hash - The hash associated with the upload */ /** * Triggered when a shard has finished downloading from this instance * @event Server#shardDownloaded * @param {string} hash - The hash associated with the download */ /** * Triggered when a error occurs * @event Server#error * @param {error} error */ /** * Begin accepting data for the given file hash and token * @param {string} token - The authorization token created for transfer * @param {string} filehash - The shard hash to allow for the token * @param {array} contact - Contact that negotiated the token */ accept(token, filehash, contact) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed.set(token, { hash: filehash, contact: contact, expires: Date.now() + this._ttl }); } /** * Stop accepting data for the given token * @param {string} token - The authorization token created for transfer */ reject(token) { assert(typeof token === 'string', 'Invalid token supplied'); this._allowed.delete(token); } /** * Validates the given token * @param {string} token * @param {string} hash * @returns {object} */ authorize(token, hash) { assert.ok(token, 'You did not supply a token'); assert.ok(this._allowed.has(token), 'The token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(this._allowed.get(token).expires &gt; Date.now(), 'Token expired'); assert(this._allowed.get(token).hash === hash, 'Token not valid'); return this._allowed.get(token); } /** * Receives the data stream and writes it to storage * @param {http.IncomingMessage} req * @param {http.ServerResponse} req */ upload(req, res) { const hasher = crypto.createHash('sha256'); const { contact, hash } = merge({}, this._allowed.get(req.query.token)); function respond(err, statusCode) { res.statusCode = statusCode; res.end(err ? err.message : ''); } let shardSize = 0; let receivedBytes = 0; async.waterfall([ (next) =&gt; { try { this.authorize(req.query.token, req.params.hash); } catch (err) { return next(err, 401); } next(); }, (next) =&gt; { const contractKey = `${hash}:${contact[1].xpub}`; this.contracts.get(contractKey, (err, contract) =&gt; { if (err) { return next(err, 404); } contract = Contract.from(contract); shardSize = contract.get('data_size'); this.shards.createWriteStream(hash, (err, writeStream) =&gt; { if (err) { return next(err, 500); } next(null, writeStream, contract); }); }); }, (writeStream, contract, next) =&gt; { // TODO: Track transfer req.on('data', (chunk) =&gt; { receivedBytes += chunk.length; hasher.update(chunk); writeStream.write(chunk); if (receivedBytes &gt; shardSize) { this.shards.unlink(hash, () =&gt; null); next(new Error('Shard exceeds size defined in contract'), 400); } }); req.on('end', () =&gt; { if (utils.rmd160(hasher.digest()).toString('hex') !== hash) { this.shards.unlink(hash, () =&gt; null); return next(new Error('Hash does not match contract'), 400); } writeStream.end(); this.reject(req.query.token); this.emit('shardUploaded', contract); next(null, 200); }); } ], respond); } /** * Pumps the data through to the client * @param {http.IncomingMessage} req * @param {http.ServerResponse} res */ download(req, res) { function respond(err, statusCode) { res.statusCode = statusCode; res.end(err.message); } async.waterfall([ (next) =&gt; { try { this.authorize(req.query.token, req.params.hash); } catch (err) { return next(err, 401); } next(); }, (next) =&gt; { const { hash } = this._allowed.get(req.query.token); this.shards.createReadStream(hash, function(err, readStream) { if (err) { return next(err, 404); } next(null, readStream, hash); }); }, (readStream, hash) =&gt; { // TODO: Track transfer res.setHeader('content-type', 'application/octet-stream'); readStream .on('error', (/* err */) =&gt; res.end()) .on('end', () =&gt; { this.emit('shardDownloaded', hash); this.reject(req.query.token); }) .pipe(res); } ], respond); } /** * Enumerates the authorized list and rejects expired * @private */ _reapExpiredTokens() { let now = Date.now(); for (let [token] of this._allowed) { if (this._allowed.get(token).expires &lt; now) { this.reject(token); } } } } module.exports = Server; × Search results Close "},"lib_shards.js.html":{"id":"lib_shards.js.html","title":"Source: lib/shards.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/shards.js 'use strict'; const merge = require('merge'); const assert = require('assert'); const fs = require('fs'); const du = require('du'); const path = require('path'); /** * Convenience wrapper for storing shards scoped to a directory */ class Shards { static get DEFAULTS() { return { maxSpaceAllocated: 0 }; } /** * @constructor * @param {string} directory - Directory path to shard storage */ constructor(directory, options) { assert.ok(directory, 'Invalid directory supplied'); assert(fs.existsSync(directory), 'Supplied directory does not exist'); this.directory = directory; this.options = merge(Shards.DEFAULTS, options); } /** * Wraps read stream with error handling/callback * @param {string} key - The file key or hash * @param {Shards~createReadStreamCallback} callback */ createReadStream(key, callback) { let rs = null; try { rs = fs.createReadStream(path.join(this.directory, key)); } catch (err) { return callback(err); } callback(null, rs); } /** * @callback Shards~createReadStreamCallback * @param {error|null} error * @param {object} stream */ /** * Wraps write stream with error handling/callback * @param {string} key - The file key or hash * @param {Shards~createWriteStreamCallback} callback */ createWriteStream(key, callback) { let ws = null; try { ws = fs.createWriteStream(path.join(this.directory, key)); } catch (err) { return callback(err); } callback(null, ws); } /** * @callback Shards~createWriteStreamCallback * @param {error|null} error * @param {object} stream */ /** * Unlink the shard from the file system * @param {string} key * @param {Shards~unlinkCallback} callback */ unlink(key, callback) { fs.unlink(path.join(this.directory, key), callback); } /** * @callback Shards~unlinkCallback * @param {error|null} error */ /** * Check if the shard exists * @param {string} key * @param {Shards~existsCallback} callback */ exists(key, callback) { callback(null, fs.existsSync(path.join(this.directory, key))); } /** * @callback Shards~existsCallback * @param {error|null} error * @param {boolean} exists */ /** * Get used space and remaining allocation * @param {Shards~sizeCallback} callback */ size(callback) { du(this.directory, (err, used) =&gt; { if (err) { return callback(err); } const allocated = this.options.maxSpaceAllocated; callback(null, { allocated, available: used &gt;= allocated ? 0 : allocated - used }); }); } /** * @callback Shards~sizeCallback * @param {error|null} error * @param {object} size */ } module.exports = Shards; × Search results Close "},"lib_transport.js.html":{"id":"lib_transport.js.html","title":"Source: lib/transport.js","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Source: lib/transport.js 'use strict'; const url = require('url'); const merge = require('merge'); const connect = require('connect'); const { HTTPSTransport } = require('kad'); const { Agent } = require('https'); /** * Represents the Orc-specific HTTP(S) transport */ class Transport extends HTTPSTransport { /** * Emitted when a download request is received * @event Transport#download * @param {object} request * @param {object} response */ /** * Emitted when a upload request is received * @event Transport#upload * @param {object} request * @param {object} response */ /** * Contructs a Orc transport adapter * @constructor * @param {object} options * @see https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options */ constructor(options) { super(options); } /** * Make sure we explicity set the keepAlive options on requests * @private */ _createRequest(options) { const request = super._createRequest(merge({ agent: new Agent({ keepAlive: true, keepAliveMsecs: 25000 }), path: '/rpc/', rejectUnauthorized: false }, options)); request.setNoDelay(true); return request; } /** * Disable nagle algorithm on connections * @private */ _createServer(options) { const server = super._createServer(options); server.on('connection', (sock) =&gt; sock.setNoDelay(true)); return server; } /** * Handles requests by sending through middleware stack * @private */ _handle() { const middleware = connect(); middleware.use(Transport.CORS); middleware.use('/', (req, res, next) =&gt; { return req.url !== '/' ? next() : this.emit('identify', req, res); }); middleware.use('/rpc/', super._handle.bind(this)); middleware.use('/shards/', this._shards.bind(this)); middleware(...arguments); } /** * Handle routing request to shard server * @private */ _shards(req, res) { const urlobj = url.parse(req.originalUrl, true); const [, hash] = urlobj.pathname.split('/shards/'); req.query = urlobj.query; req.params = { hash }; if (req.method === 'POST') { this.emit('upload', req, res); } else if (req.method === 'GET') { this.emit('download', req, res); } else { res.statusCode = 405; res.end(); } } /** * Applies cross origin headers to responses * @static * @memberof Transport * @private */ static get CORS() { return function(req, res, next) { res.setHeader('access-control-allow-origin', '*'); res.setHeader('access-control-allow-methods', '*'); res.setHeader('access-control-allow-headers', '*'); if (req.method === 'OPTIONS') { res.statusCode = 200; res.end(); } else { next(); } } } } module.exports = Transport; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Modules Classes Audit Bridge Contract FarmerProfile Profile RenterProfile Node Offers Proof Rules Server Shards Transport Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Classes Classes Audit Bridge Contract FarmerProfile Profile RenterProfile Node Offers Proof Rules Server Shards Transport Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Tutorials Classes Audit Bridge Contract FarmerProfile Profile RenterProfile Node Offers Proof Rules Server Shards Transport Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide The Onion Routed Cloud. ORC is a distributed anonymous cloud storage network owned and operated by all of us. Join the discussion in #orc on our community chat! | | | Quick StartPull the image from Docker Hub. docker pull orcproject/orcCreate a data directory on the host. mkdir path/to/orc.dataRun the ORC container and mount the data directory. docker run -v path/to/orc.data:/root/.config/orc -t orcproject/orc:latestModify the created configuration at path/to/orc.data/config as desired (see the Configuration Guide) and restart the container for the changes to take effect. You might wish to expose the ports defined for ControlPort and BridgePort to the host (and update ControlHostname and BridgeHostname to 0.0.0.0) and map them to the host. docker run \\ --publish 127.0.0.1:4444:4444 \\ --publish 127.0.0.1:4445:4445 \\ --expose 4444 \\ --expose 4445 \\ --volume path/to/orc.data:/root/.config/orc \\ --tty orcproject/orc:latestSee the docker run documentation for more information. If you prefer to install ORC manually, see the guide for Manual Installation. Once installed, simply run orc with an optional configuration file using the --config &lt;path/to/config&gt; option. Resources Documentation Specification Whitepaper LicenseORC - Distributed Anonymous CloudCopyright (C) 2017 Gordon HallCopyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close "},"Audit.html":{"id":"Audit.html","title":"Class: Audit","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Audit Audit Represents a streaming audit challenge generator new Audit(audits) Parameters: Name Type Description audits number Total number of challenges to generate Source: lib/audit.js Methods &lt;static&gt; fromRecords(challenges, tree) Returns a new instance from the predefined challenges and tree Parameters: Name Type Description challenges array The precomputed challenges tree array The bottom leaves of the existing merkle tree Source: lib/audit.js Returns: Type Audit getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/audit.js Returns: challenge - Private audit record with challenges Type Object getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/audit.js Returns: leaves - Bottom merkle leaves of audit tree Type Array × Search results Close "},"Bridge.html":{"id":"Bridge.html","title":"Class: Bridge","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Bridge Bridge Represents a local HTTP(s) server that abstracts the upload and download of files away to a simple request. Files are encrypted to the given public key, split into shards for erasure codes. Prepped for distribution and queued for storing in the network. Bridge exposes a simple API for getting status of transfers and previously stored objects. GET / (List objects as JSON) GET /{hash} (Download object) DELETE /{hash} (Delete object) POST / (Upload object - Multipart) new Bridge(node) Parameters: Name Type Description node Node Source: lib/bridge.js Methods audit(callback) Periodically call this to scan the object store for shards that need to be audited, perform audit, and issue payment Parameters: Name Type Description callback function Source: lib/bridge.js authenticate(request, response, next) Handles request authentication if defined Parameters: Name Type Description request object response object next function Source: lib/bridge.js createRequestHandler() Creates request router and handler stack Source: lib/bridge.js Returns: Type function destroy(request, response, next) Ends contracts with farmers for the object parts and removes reference to them Parameters: Name Type Description request object response object next function Source: lib/bridge.js distribute(filepath, metadata) Takes the supplied file path and applies erasure codes, then attempts to distribute the shards across the network Parameters: Name Type Description filepath string Path to the file to distribute metadata object Properties Name Type Description encoding string mimetype string hash string Source: lib/bridge.js Returns: Type EventEmitter download(request, response, next) Downloads the object from the network Parameters: Name Type Description request object response object next function Source: lib/bridge.js error(error, request, response, next) Responds to requests with error code and message Parameters: Name Type Description error error request object response object next function Source: lib/bridge.js list(request, response, next) Scans the object database and returns all index entries Parameters: Name Type Description request object response object next function Source: lib/bridge.js listen(port, hostname, callback) Listens on the given port and hostname Parameters: Name Type Description port number hostname string callback function Source: lib/bridge.js route(request, response, next) Handles routing requests to their appropriate handler Parameters: Name Type Description request object response object next function Source: lib/bridge.js upload(request, response, next) Queues the object for upload to the network Parameters: Name Type Description request object response object next function Source: lib/bridge.js × Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Contract Contract Represents a storage contract between a renter and a farmer new Contract(contract, criteria) Parameters: Name Type Description contract object Properties Name Type Argument Description type string Unique identifier for the contract renter_hd_key string &lt;optional&gt; Node extended public key in base58 renter_hd_index number &lt;optional&gt; Derivation index for signature renter_id string Node ID of the renter renter_signature string Renter's cryptographic signature farmer_hd_key string &lt;optional&gt; Node extended public key in base58 farmer_hd_index number &lt;optional&gt; Derivation index for signature farmer_id string Node ID of the farmer farmer_signature string Farmer's cryptographic signature data_size number Number of bytes to store data_hash string RIPEMD-160 SHA-256 hash of the data store_begin number UNIX timestamp to start contract store_end number UNIX timestamp to end the contract audit_count number Number of audits renter will perform audit_leaves Array.&lt;string&gt; Merkle leaves for audit tree payment_storage_price number Total price for storage payment_download_price number Price per download payment_destination string Zcash address to send funds criteria object Properties Name Type Description size number Criteria degree OPCODE duration number Criteria degree OPCODE availability number Criteria degree OPCODE speed number Criteria degree OPCODE Source: lib/contract.js Members &lt;static&gt; CRITERIA Defines some default criteria of a Contract Source: lib/contract.js &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract.js &lt;static&gt; MATRIX Defines the criteria matrix for a Contract Source: lib/contract.js &lt;static&gt; schema Defines the JSON Schema of a Contract Source: lib/contract.js &lt;static&gt; validator Validation function against the schema Source: lib/contract.js Methods &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract.js Returns: Type boolean &lt;static&gt; createTopic(criteria) Create a topical OPCODE byte sequence from the provided criteria Parameters: Name Type Description criteria object Properties Name Type Description size number Criteria degree OPCODE duration number Criteria degree OPCODE availability number Criteria degree OPCODE speed number Criteria degree OPCODE Source: lib/contract.js Returns: Type buffer &lt;static&gt; diff(c1, c2) Returns the property names between two contracts that differ Parameters: Name Type Description c1 Contract Contract to compare c2 contract Contract to compare Source: lib/contract.js Returns: changedProperties Type Array.&lt;string&gt; &lt;static&gt; from(data) Infers the type of object supplied and constructs a contract Parameters: Name Type Description data object | string | buffer Source: lib/contract.js Returns: Type Contract &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer buffer Raw binary blob of contract data Source: lib/contract.js Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json string JSON encoded contract Source: lib/contract.js Returns: Type Contract &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object object Dictionary of contract data Source: lib/contract.js Returns: Type Contract get(field) Returns the value for the given contract property Parameters: Name Type Description field string Contract property to get Source: lib/contract.js Returns: value Type string | number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract.js Returns: Type buffer getSigningData() Returns the string representation of the contract, minus the signature fields, sorted alphanumerically for signing and verifying Source: lib/contract.js Returns: Type string getTopicBuffer() Return OPCODE byte sequence for contract publication topic Source: lib/contract.js Returns: Type buffer getTopicString() Return OPCODE byte sequence for contract publication topic as hex string Source: lib/contract.js Returns: Type string isComplete() Checks if the contract is complete Source: lib/contract.js Returns: completed Type boolean set(field, value) Sets the contract property to the given value Parameters: Name Type Description field string Contract property to set value string | number Value to set for field Source: lib/contract.js Returns: Type string | number | null sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor string One of 'farmer' or 'renter' secret buffer ECDSA private key Source: lib/contract.js Returns: signature Type string signExternal(secret) Signs the contract with the proved key and returns the signature Parameters: Name Type Description secret buffer ECDSA private key Source: lib/contract.js Returns: Type buffer toBuffer() Converts the contract to Buffer Source: lib/contract.js Returns: Type buffer toJSON() Converts the contract to JSON string Source: lib/contract.js Returns: Type string toObject() Converts the contract to a plain object Source: lib/contract.js Returns: Type object update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields object Contract properties to update Source: lib/contract.js Returns: Type Contract verify(actor) Verify the contract signature for the given actor Parameters: Name Type Description actor string One of 'farmer' or 'renter' Source: lib/contract.js Returns: Type boolean verifyExternal(signature, pubkey) Verify the provided signature for the contract Parameters: Name Type Description signature buffer The contract signature to verify pubkey buffer ECDSA public key Source: lib/contract.js Returns: Type boolean × Search results Close "},"module-orc.html":{"id":"module-orc.html","title":"Module: orc","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Module: orc (require(&quot;orc&quot;))(config) Forks a child orc process and returns the child process and a controller client for sending commands to it Parameters: Name Type Description config object | string Configuration properties as object or path to a configuration file. See Configuration Guide for details. connect to the control port Source: index.js Returns: Type object Members &lt;static&gt; Audit Audit Source: index.js &lt;static&gt; Bridge Bridge Source: index.js &lt;static&gt; constants module:orc/constants Source: index.js &lt;static&gt; Contract Contract Source: index.js &lt;static&gt; control Source: index.js See: https://github.com/bookchin/boscar &lt;static&gt; Node Node Source: index.js &lt;static&gt; Offers Offers Source: index.js &lt;static&gt; profiles module:orc/profiles Source: index.js &lt;static&gt; Proof Proof Source: index.js &lt;static&gt; Rules Rules Source: index.js &lt;static&gt; Server Server Source: index.js &lt;static&gt; Shards Shards Source: index.js &lt;static&gt; Transport Transport Source: index.js &lt;static&gt; utils module:orc/utils Source: index.js &lt;static&gt; version module:orc/version Source: index.js × Search results Close "},"module-orc_constants.html":{"id":"module-orc_constants.html","title":"Module: orc/constants","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Module: orc/constants Source: lib/constants.js Members &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js &lt;inner, constant&gt; CLEAN_INTERVAL :Number Interval for reaping stale shards Type: Number Source: lib/constants.js &lt;inner, constant&gt; CONSIGN_THRESHOLD :Number Threshold for consign time Type: Number Source: lib/constants.js &lt;inner, constant&gt; HD_KEY_DERIVATION_PATH Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_AUDITS :Number Number of concurrent audits Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_OFFERS :Number Number of concurrent offers Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_NODE_INDEX Source: lib/constants.js &lt;inner, constant&gt; OFFER_TIMEOUT :Number Max wait time for storage offer Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_CONTRACT_PREFIX :Number Prefix opcode for contracts Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_HIGH :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_LOW :Number Opcode for low criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_MED :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_NULL :Number Opcode for null criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; TOKEN_EXPIRE :Number Reject datachannl token after time Type: Number Source: lib/constants.js × Search results Close "},"module-orc_profiles.html":{"id":"module-orc_profiles.html","title":"Module: orc/profiles","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Module: orc/profiles Source: lib/profiles.js Classes FarmerProfile Profile RenterProfile Methods &lt;static&gt; farmer(node, config) Applies the farmer profile Parameters: Name Type Description node Node config object Source: lib/profiles.js Returns: Type FarmerProfile &lt;static&gt; renter(node, config) Applies the renter profile Parameters: Name Type Description node Node config object Source: lib/profiles.js Returns: Type RenterProfile × Search results Close "},"module-orc_profiles-FarmerProfile.html":{"id":"module-orc_profiles-FarmerProfile.html","title":"Class: FarmerProfile","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: FarmerProfile orc/profiles~ FarmerProfile Applies the farmer profile to the supplied node. A farmer publishes capacity announcements, subscribes to contract publications, and reaps stale shards. new FarmerProfile(node, config) Parameters: Name Type Description node Node config object Source: lib/profiles.js Methods announceCapacity(callback) Announces current storage capacity to neighbors Parameters: Name Type Description callback FarmerProfile~announceCapacityCallback Source: lib/profiles.js reapExpiredShards(callback) Scans the contract database for expired shards and reaps them from storage Parameters: Name Type Description callback FarmerProfile~reapExpiredShardsCallback Source: lib/profiles.js × Search results Close "},"module-orc_profiles-Profile.html":{"id":"module-orc_profiles-Profile.html","title":"Class: Profile","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Profile orc/profiles~ Profile Base class for a profile, sets up zcash wallet and other shared profile behavior new Profile(node, config) Parameters: Name Type Description node Node config object Source: lib/profiles.js Methods getNewAddress(callback) Generates a new zcash address Parameters: Name Type Description callback Profile~getNewAddressCallback Source: lib/profiles.js × Search results Close "},"module-orc_profiles-RenterProfile.html":{"id":"module-orc_profiles-RenterProfile.html","title":"Class: RenterProfile","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: RenterProfile orc/profiles~ RenterProfile Applies the renter profile to the supplied node. A renter listens for capacity announcements and keeps a cache, exposes a local bridge for upload/download, handles auditing, mirroring, and payments. new RenterProfile(node, config) Parameters: Name Type Description node Node config object Source: lib/profiles.js Methods getCapacityCache(callback) Exposes the capacity cache over the control port Parameters: Name Type Description callback RenterProfile~getCapacityCacheCallback Source: lib/profiles.js × Search results Close "},"module-orc_utils.html":{"id":"module-orc_utils.html","title":"Module: orc/utils","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Module: orc/utils Source: lib/utils.js Methods &lt;static&gt; createCipher(publicKey, privateKey) Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret derived from the given public and private keys Parameters: Name Type Description publicKey buffer SECP256k1 public key bytes privateKey buffer SECP256k1 private key bytes Source: lib/utils.js Returns: Type object &lt;static&gt; createComplexKeyFromSeed(seed64) Returns a HD key object using corrent key derivation path using the given seed Parameters: Name Type Description seed64 buffer 64 byte seed for generating key Source: lib/utils.js Returns: Type HDKey &lt;static&gt; createDecipher(publicKey, privateKey) Returns a cipher stream using aes256-cbc-sha256-hmac using a ECDH secret derived from the given public and private keys Parameters: Name Type Description publicKey buffer SECP256k1 public key bytes privateKey buffer SECP256k1 private key bytes Source: lib/utils.js Returns: Type object &lt;static&gt; createShardDownloader(farmer, hash, token) Returns a request object for downloading a shard from a farmer Parameters: Name Type Description farmer array Farmer contact object hash string The hash of the shard to upload token string The authorized transfer token Source: lib/utils.js Returns: Type https.ClientRequest &lt;static&gt; createShardUploader(farmer, hash, token) Returns a request object for uploading a shard to a farmer Parameters: Name Type Description farmer array Farmer contact object hash string The hash of the shard to upload token string The authorized transfer token Source: lib/utils.js Returns: Type https.ClientRequest &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact array Properties Name Type Description 0 string Node identity key 1 object Properties Name Type Description hostname string port string protocol string Source: lib/utils.js Returns: Type string &lt;static&gt; getErasureParameters(n) Returns the appropriate shard size, number of shards, and number of parity shards for RS encoding/decoding provided the total number of bytes of the complete content Parameters: Name Type Description n number Number of bytes in data Source: lib/utils.js Returns: Type object &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number number Source: lib/utils.js Returns: Type number &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version string The semver tag from the contact Source: lib/utils.js Returns: Type boolean &lt;static&gt; isHexaString(a) Determines if a value is hexadecimal string Parameters: Name Type Description a * The value to be tested Source: lib/utils.js Returns: Type boolean &lt;static&gt; isValidContact(contact, loopback) Determines if the supplied contact is valid Parameters: Name Type Description contact array The contact information for a given peer loopback boolean Allows contacts that are localhost Source: lib/utils.js Returns: Type boolean &lt;static&gt; isValidHDNodeKey(hdKey) Checks if the supplied HD key is valid (base58 encoded) and proper length Parameters: Name Type Description hdKey string The HD key in base 58 encoding Source: lib/utils.js Returns: isValidHDKey Type boolean &lt;static&gt; isValidNodeIndex(hdIndex) Checks if the input is a non-hardened HD key index Parameters: Name Type Description hdIndex number The HD key index Source: lib/utils.js Returns: isValidHDKeyIndex Type boolean &lt;static&gt; rmd160(input, encoding) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: lib/utils.js Returns: Type buffer &lt;static&gt; rmd160sha256(input, encoding) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: lib/utils.js Returns: Type buffer &lt;static&gt; sha256(input, encoding) Returns the SHA-256 hash of the input Parameters: Name Type Description input string | buffer Data to hash encoding string The encoding type of the data Source: lib/utils.js Returns: Type buffer × Search results Close "},"module-orc_version.html":{"id":"module-orc_version.html","title":"Module: orc/version","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Module: orc/version Source: lib/version.js Members &lt;inner, constant&gt; protocol :string The supported protocol version Type: string Source: lib/version.js &lt;inner, constant&gt; software :string The current software version Type: string Source: lib/version.js Methods &lt;static&gt; toString() Returns human readable string of versions Source: lib/version.js Returns: Type string × Search results Close "},"Node.html":{"id":"Node.html","title":"Class: Node","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Node Node Extends Kademlia with Orc protocol rules new Node(options) Parameters: Name Type Description options object Properties Name Type Argument Description privateExtendedKey string HD extended private key logger object &lt;optional&gt; Bunyan compatible logger transport object &lt;optional&gt; Orc transport adapter contracts object Levelup compatible contract store shards object KFS compatible shard database claims Array.&lt;string&gt; &lt;optional&gt; Enable direct capacity claims from the given public extended keys keyDerivationIndex number &lt;optional&gt; HD derivation index License: AGPL-3.0 Source: lib/node.js Methods auditRemoteShards(peer, audits, callback) Sends the series of hash/challenge pairs to the remote node to request proof-of-storage Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact audits Array.&lt;object&gt; Properties Name Type Description hash string Hash of the shard to prove challenge string Challenge string to prepend to shard callback Node~auditRemoteShardsCallback Source: lib/node.js authorizeConsignment(peer, hashes, callback) Requests authorization tokens to push file shard(s) to another node Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hashes Array.&lt;string&gt; Hashes of the shards to push callback Node~authorizeConsignmentCallback Source: lib/node.js authorizeRetrieval(peer, hashes, callback) Requests authorization tokens to pull file shard(s) from another node Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hashes Array.&lt;string&gt; Hashes of the shards to pull callback Node~authorizeRetrievalCallback Source: lib/node.js claimFarmerCapacity(peer, descriptor, callback) Claims capacity from a farming node, given a valid contract Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact descriptor object Contract descriptor callback Node~claimFarmerCapacityCallback Source: lib/node.js createShardMirror(source, target, callback) Requests the source node to MIRROR a shard to the supplied destination Parameters: Name Type Description source array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact target object Properties Name Type Description destination array - Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact hash string Hash of the shard to mirror token string Authorization token to PUSH shard callback Node~createShardMirrorCallback Source: lib/node.js identifyService(url, callback) Sends a GET request to the URI and parses the result as a valid contact object with identity Parameters: Name Type Description url string The URL of the node callback Node~identifyServiceCallback Source: lib/node.js listen() Adds the kademlia rule handlers before calling super#listen() Source: lib/node.js offerShardAllocation(peer, contract, callback) Offers a peer an allocation for the storage of a given shard descriptor-turned-contract, see storage-contracts for details Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 string | object Address data for contact contract object The completed shard descriptor contract callback Node~offerShardAllocationCallback Source: lib/node.js publishCapacityAnnouncement(descriptorCode, bytesAvailable, callback) Announces to interested renter nodes that this node has capacity available for renting. Parameters: Name Type Description descriptorCode Array.&lt;string&gt; See protocol bytesAvailable number Total bytes capacity available callback Node~publishCapacityAnnouncementCallback Source: lib/node.js publishShardDescriptor(contract [, offerStreamOptions], callback) Publishes a storage contract proposal to the network and exposes a stream of received OFFER messages Parameters: Name Type Argument Description contract object See storage-contracts for format offerStreamOptions object &lt;optional&gt; See OfferStream callback Node~publishShardDescriptorCallback Source: lib/node.js requestContractRenewal(peer, contract, callback) Requests that the target peer update their local version of the given contract. Used to extend storage time or terminate storage. Peer will respond with an error or their updated, signed record of the renewal. Parameters: Name Type Description peer array Properties Name Type Description 0 string Identity key string 1 object Address data for contact contract object The completed shard descriptor contract callback Node~requestContractRenewalCallback Source: lib/node.js resolveContractOffer(hash, offer, error, contract, callback) Resolves the offer for the given shard hash and offer identifier Parameters: Name Type Description hash string Shard hash for the contract offer string Unique offer identifier error error | null If applicable an error object contract object | null The resolved and signed contract callback Node~resolveContractOfferCallback Source: lib/node.js subscribeCapacityAnnouncement(descriptorCodes, callback) Subscribes to capacity announcements for the given topic codes and exposes announcements as a stream. Parameters: Name Type Description descriptorCodes Array.&lt;string&gt; See protocol callback Node~subscribeCapacityAnnouncementCallback Source: lib/node.js subscribeShardDescriptor(descriptorCodes, callback) Subscribes to the supplied shard descriptor topics and executes the user and exposes a stream of incoming shard descriptor messages Parameters: Name Type Description descriptorCodes Array.&lt;string&gt; See protocol callback Node~subscribeShardDescriptorCallback Source: lib/node.js Type Definitions auditRemoteShardsCallback(error, proofs) Parameters: Name Type Description error object | null proofs Array.&lt;object&gt; Properties Name Type Description hash string Hash of the shard for corresponding proof proof string compact-merkle-proof Source: lib/node.js authorizeConsignmentCallback(error, consignmentTokens) Parameters: Name Type Description error error | null consignmentTokens Array.&lt;string&gt; Source: lib/node.js authorizeRetrievalCallback(error, retrievalTokens) Parameters: Name Type Description error error | null retrievalTokens Array.&lt;string&gt; Source: lib/node.js claimFarmerCapacityCallback(error, result) Parameters: Name Type Description error error | null result array Properties Name Type Description 0 object Completed contract result 1 string Consignment token Source: lib/node.js createShardMirrorCallback(error) Parameters: Name Type Description error object | null Source: lib/node.js identifyServiceCallback(error, contact) Parameters: Name Type Description error error | null contact array Source: lib/node.js offerShardAllocationCallback(error, contract) Parameters: Name Type Description error error | null contract object See storage-contracts Source: lib/node.js publishCapacityAnnouncementCallback(error) Parameters: Name Type Description error error | null Source: lib/node.js publishShardDescriptorCallback(error, offerStream) Parameters: Name Type Description error error | null offerStream Offers Readable stream of OFFER messages Source: lib/node.js requestContractRenewalCallback(error, contract) Parameters: Name Type Description error error | null contract object See storage-contracts Source: lib/node.js resolveContractOfferCallback(error) Parameters: Name Type Description error error | null Source: lib/node.js subscribeCapacityAnnouncementCallback(error, capacityStream) Parameters: Name Type Description error error | null capacityStream ReadableStream Source: lib/node.js subscribeShardDescriptorCallback(error, descriptorStream) Parameters: Name Type Description error error | null descriptorStream ReadableStream Readable stream of incoming shard descriptors Source: lib/node.js × Search results Close "},"Offers.html":{"id":"Offers.html","title":"Class: Offers","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Offers Offers Manages a stream of offers for a given storage contract publication new Offers(contract [, options]) Parameters: Name Type Argument Description contract Contract Storage contract published to network options Object &lt;optional&gt; Properties Name Type Argument Description maxOffers Number &lt;optional&gt; Maximum number of offers to process farmerBlacklist Array.&lt;String&gt; &lt;optional&gt; Reject offers from nodeID Source: lib/offers.js Methods destroy() Tears down listeners and ends the stream Source: lib/offers.js queue(contact, contract, callback) Adds the offer to the internal queue if there is room Parameters: Name Type Description contact array The sending farmer for the offer contract object The received offer contract callback function Source: lib/offers.js Events data Triggered when an offer is received Parameters: Name Type Description data Object Properties Name Type Description contact Contact The sending farmer for the offer contract Contract The received offer contract Source: lib/offers.js end Triggered when the maximum number of offers are received and processed Source: lib/offers.js error Triggered if an error occurs Parameters: Name Type Description error Error The error object with message Source: lib/offers.js × Search results Close "},"Proof.html":{"id":"Proof.html","title":"Class: Proof","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Proof Proof Provides interface for proving possession of a file for an AuditStream new Proof(merkleLeaves, hexChallenge) Parameters: Name Type Description merkleLeaves Array.&lt;string&gt; Bottom leaves of the audit merkle tree hexChallenge string | buffer The challenge data in hex to prepend to shard Source: lib/proof.js Methods &lt;static&gt; verify(proof, root, depth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description proof * Compact proof result root string Merkle tree root from audit leaves depth number Depth of the merkle tree Source: lib/proof.js Returns: Type Array.&lt;string&gt; getProofResult() Returns the generated proof structure Source: lib/proof.js Returns: Type array × Search results Close "},"Rules.html":{"id":"Rules.html","title":"Class: Rules","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Rules Rules Represents Orc protocol handlers new Rules(node) Constructs a Orc rules instance in the context of a Orc node Parameters: Name Type Description node Node Source: lib/rules.js Methods audit(request, response) Upon receipt of a AUDIT message, the node must look up the contract that is associated with each hash-challenge pair in the payload, prepend the challenge to the shard data, and caclulate the resulting hash, formatted as a compact proof. See compact-proofs. Parameters: Name Type Description request object response object Source: lib/rules.js claim(request, response) Upon receipt of an `CLAIM` message, nodes must validate the descriptor, then ensure that there is enough available space for the shard. If both checks succeed, then the descriptor is signed and returned along with a consignment token so the initiating renter can immediately upload the data. This call is the functional inverse of `OFFER`, as it is used for a renter to signal to a farmer that it wishes to rent capacity. These messages are generally sent based on information collected when subscribed to farmer capacity publications. Parameters: Name Type Description request object response object Source: lib/rules.js consign(request, response) Upon receipt of a CONSIGN message, the node must verify that it has a valid storage allocation and contract for the supplied hash and identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: Name Type Description request object response object Source: lib/rules.js mirror(request, response) Upon receipt of a MIRROR message, the node must verify that it is in possesion of the shard on behalf of the identity or the message originator. If so, given the token-hash pair, it must attempt to upload it's copy of the shard to the target to establish a mirror. Parameters: Name Type Description request object response object Source: lib/rules.js offer(request, response) Upon receipt of an OFFER message, nodes must validate the descriptor, then ensure that the referenced shard is awaiting allocation(s). If both checks succeed, then the descriptor is added to the appropriate offer processing stream. Once the descriptor is processed, we respond back to the originator with the final copy of the contract. Parameters: Name Type Description request object response object Source: lib/rules.js probe(request, response) Upon receipt of a PROBE message, the node must attempt to send a PING message to the originator using the declared contact information. If successful, it must respond positively, otherwise error. Parameters: Name Type Description request object response object Source: lib/rules.js renew(request, response) Upon receipt of a RENEW message, the recipient farmer must extend or terminate it's contract based on the new terms supplied by the renter. If the renewal descriptor is valid and complete, the farmer must store the updated version after signing and respond back to the originator with the version containing the updated signature. Parameters: Name Type Description request object response object Source: lib/rules.js retrieve(request, response) Upon receipt of a RETRIEVE message, the node must verify that it is in possession of the shard on behalf of the identity of the originator. If so, it must generate an authorization token which will be checked by the shard server before accepting the transfer of the associated shard. Parameters: Name Type Description request object response object Source: lib/rules.js × Search results Close "},"Server.html":{"id":"Server.html","title":"Class: Server","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Server Server Creates a shard server for sending and receiving consigned file shards new Server(options) Parameters: Name Type Description options object Properties Name Type Argument Default Description identity string Node identity key contracts object Contract database shards object KFS shard database tokenTtl number &lt;optional&gt; 1800000 Expire unused token Source: lib/server.js Methods accept(token, filehash, contact) Begin accepting data for the given file hash and token Parameters: Name Type Description token string The authorization token created for transfer filehash string The shard hash to allow for the token contact array Contact that negotiated the token Source: lib/server.js authorize(token, hash) Validates the given token Parameters: Name Type Description token string hash string Source: lib/server.js Returns: Type object download(req, res) Pumps the data through to the client Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: lib/server.js reject(token) Stop accepting data for the given token Parameters: Name Type Description token string The authorization token created for transfer Source: lib/server.js upload(req, req) Receives the data stream and writes it to storage Parameters: Name Type Description req http.IncomingMessage req http.ServerResponse Source: lib/server.js Events error Triggered when a error occurs Parameters: Name Type Description error error Source: lib/server.js shardDownloaded Triggered when a shard has finished downloading from this instance Parameters: Name Type Description hash string The hash associated with the download Source: lib/server.js shardUploaded Triggered when a shard has finished uploading to this instance Parameters: Name Type Description hash string The hash associated with the upload Source: lib/server.js × Search results Close "},"Shards.html":{"id":"Shards.html","title":"Class: Shards","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Shards Shards Convenience wrapper for storing shards scoped to a directory new Shards(directory) Parameters: Name Type Description directory string Directory path to shard storage Source: lib/shards.js Methods createReadStream(key, callback) Wraps read stream with error handling/callback Parameters: Name Type Description key string The file key or hash callback Shards~createReadStreamCallback Source: lib/shards.js createWriteStream(key, callback) Wraps write stream with error handling/callback Parameters: Name Type Description key string The file key or hash callback Shards~createWriteStreamCallback Source: lib/shards.js exists(key, callback) Check if the shard exists Parameters: Name Type Description key string callback Shards~existsCallback Source: lib/shards.js size(callback) Get used space and remaining allocation Parameters: Name Type Description callback Shards~sizeCallback Source: lib/shards.js unlink(key, callback) Unlink the shard from the file system Parameters: Name Type Description key string callback Shards~unlinkCallback Source: lib/shards.js Type Definitions createReadStreamCallback(error, stream) Parameters: Name Type Description error error | null stream object Source: lib/shards.js createWriteStreamCallback(error, stream) Parameters: Name Type Description error error | null stream object Source: lib/shards.js existsCallback(error, exists) Parameters: Name Type Description error error | null exists boolean Source: lib/shards.js sizeCallback(error, size) Parameters: Name Type Description error error | null size object Source: lib/shards.js unlinkCallback(error) Parameters: Name Type Description error error | null Source: lib/shards.js × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Class: Transport Transport Represents the Orc-specific HTTP(S) transport new Transport(options) Contructs a Orc transport adapter Parameters: Name Type Description options object Source: lib/transport.js Events download Emitted when a download request is received Parameters: Name Type Description request object response object Source: lib/transport.js upload Emitted when a upload request is received Parameters: Name Type Description request object response object Source: lib/transport.js × Search results Close "},"tutorial-config.html":{"id":"tutorial-config.html","title":"Tutorial: Configuration Guide","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Configuration Guide This guide will show you how to get started with running orc! An Orc node requires a configuration file to get up and running. The path to this file is given to orc when starting a node. orc --config path/to/orc.configIf a configuration file is not supplied, a minimal default configuration is automatically created and used, which will generate a private extended key, self-signed SSL certificate, and storage for shards, contracts, and directory information. All of this data will be created and stored in $HOME/.config/orc, yielding a directory structure like this: +- ~/.config/orc + - x_private_key + - onion_key + - config + - service_key.pem + - certificate.pem + - /contracts.db + - ... + - /shards.kfs + - ... + - /directory.db + - ...The locations of all of these files is defined in your configuration file. Below is a complete sample config in INI format (though JSON is also supported). Comments are inline to describe each property. Default Configuration; ; Orc Sample Configuration ; ; Path to private extended key file to use for master identity. ; Generate one with: ; ; orctool generate-key --extended &gt;&gt; x_private_key ; PrivateExtendedKeyPath = /home/bookchin/.config/orc/x_private_key ; The index for deriving this child node's identity. This allows you to run ; multiple nodes with the same private extended key. If your private extended ; key was converted from an old non-hierarchically-deterministic private key, ; you must set the value to -1 ChildDerivationIndex = 0 ; Set the base directory (parent) for where the contracts.db folder will be ; placed. The contracts.db holds storage contracts between you and other nodes. ContractStorageBaseDir = /home/bookchin/.config/orc ; Set the base directory (parent) for where the shards.kfs folder will be ; placed. The shards.kfs stores other nodes data shards, so be sure you set ; this to where you intend to store farmed shards. ShardStorageBaseDir = /home/bookchin/.config/orc ; Define the maximum size you wish to allocate for farming shards. This can be ; increased later, but decreasing it will not delete existing data. ShardStorageMaxAllocation = 0GB ; Enables renter nodes to directly claim storage capacity based on any capacity ; announcements you have made. If you are farming, set this value once for every ; trusted renter public extended key from which you will accept claims or once ; with a value of * AllowDirectStorageClaims[] = * ; Set the base directory (parent) for where the directory.db folder will be ; placed. The directory.db holds key-value pairs for the distributed hash ; table, which serve various purposes such as reputation data on other peers. DirectoryStorageBaseDir = /home/bookchin/.config/orc ; Paths to this node's SSL key and certificat. If you don't have one, you can ; generate one with the following: ; ; orctool generate-cert | csplit - 28 ; mv xx00 service_key.pem ; mv xx01 certificate.pem ; TransportServiceKeyPath = /home/bookchin/.config/orc/service_key.pem TransportCertificatePath = /home/bookchin/.config/orc/certificate.pem ; Path to this node's RSA1024 Tor hidden service private key. If this path does ; not exist, it will be automatically generated for you. If you'd like to ; generate one yourself, you can use: ; ; orctool generate-onion &gt;&gt; onion_key ; OnionServicePrivateKeyPath = /home/bookchin/.config/orc/onion_key ; Set the public port number at which your node will be reachable to others. ; This should be the port you forwarded. PublicPort = 443 ; Set the local port to bind the node service. ListenPort = 4443 ; Enables bandwidth metering and hibernation mode. When the property ; BandwidthAccountingEnabled is 1, we will enter low-bandwidth mode if the we ; exceed BandwidthAccountingMax within the period defined by the property ; BandwidthAccountingReset until the interval is finished BandwidthAccountingEnabled = 0 BandwidthAccountingMax = 5GB BandwidthAccountingReset = 24HR ; Set to 1 for more detailed logging, which is useful for debugging VerboseLoggingEnabled = 1 ; Set the ControlPort to bind the control interface. Used for controlling the ; node from other applications. Be sure that ControlHostname is kept set to ; a loopback address, unless you have taken other measures to prevent others ; from controlling your node. ControlPort = 4444 ControlHostname = 127.0.0.1 ; Add a map of network bootstrap nodes to this section to use for discovering ; other peers. Default configuration should come with a list of known and ; trusted contacts. Formatted as &quot;https://{onion}:{port}&quot;. NetworkBootstrapNodes[] = https://orcjd7xgshpovm6i.onion:443 NetworkBootstrapNodes[] = https://orcjfg52ty6ljv54.onion:443 NetworkBootstrapNodes[] = https://orce4nqoa6muz3gt.onion:443 NetworkBootstrapNodes[] = https://orcwfkilxjxo63mr.onion:443 ; Instruct Tor to establish new circuits by sending the NEWNYM sigal every so ; often. This helps mitigate Tor relays in your path going down after a while. CircuitRefreshInterval = 10M ; Instruct Tor to establish a new rendezvous point for reaching your Orc node ; every so often. This helps mitigate Tor relays in your path going down after ; a while. ServiceRefreshInterval = 35M ; When enabled via &quot;renter&quot; profile, bind a local bridge server that allows for ; GET and POST HTTP requests for uploading and downloading files from the ; network. The bridge will handle encryption and erasure coding for you. ; Optionally, protect the local bridge access using HTTP Basic Authentication ; credentials defined here. BridgeEnabled = 0 BridgeStorageBaseDir = /home/bookchin/.config/orc BridgeHostname = 127.0.0.1 BridgePort = 4445 BridgeAuthenticationEnabled = 0 BridgeAuthenticationUser = orc BridgeAuthenticationPassword = 1b5d3daa16b3343560bcf0377547b1c0 BridgeMetaStoragePath = /home/bookchin/.config/orc/objects.meta BridgeTempStagingBaseDir = /home/bookchin/.config/orc/__bridge.staging BridgeShardAuditInterval = 5DAYS ; Topic codes used when running a renter profile for listening for capacity ; announcements from the network. See the protocol specification for more ; details. It is mostly reccommended to leave these at their default values. RenterListenTopics[] = 01020202 RenterListenTopics[] = 02020202 RenterListenTopics[] = 03020202 ; Path to a file for caching network capacity announcements RenterCapacityCachePath = /home/bookchin/.config/orc/capacity.cache ; Complete information about how orc should connect to the Zcash RPC server. ; Orc needs this to generate addresses for farmers, send payments from renters, ; check balances, etc. WalletHostname = localhost WalletPort = 8232 WalletUser = orc WalletPassword = orc WalletShieldedTransactions = 0 ; Pre-scripted profiles to enable after bootstrapping. ; Renter profiles listen for capacity announcements and build a cache while ; exposing a bridge server for uploading and downloading data. ; Farmer profiles publish capacity announcements and listen for contracts to ; store data. ;ProfilesEnabled[] = renter ;ProfilesEnabled[] = farmer ; Topic codes to use when operating under the farmer profile for subscibing to ; contract publications and announcing capacity. See the protocol specification ; for more details. It is mostly reccommended to leave these at their default ; values. FarmerAdvertiseTopics[] = 01020202 FarmerAdvertiseTopics[] = 02020202 FarmerAdvertiseTopics[] = 03020202 ; How often a farmer profile should scan contract database to reap expired ; shards it is storing. FarmerShardReaperInterval = 24HR ; How often a farmer profile should publish a capacity announcement to it's ; neighboring nodes. FarmerAnnounceInterval = 1HR × Search results Close "},"tutorial-install.html":{"id":"tutorial-install.html","title":"Tutorial: Manual Installation","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Manual Installation Make sure you have the following prerequisites installed: Zcash Tor Git Node.js LTS + NPM (6.10.x) Python 2.7 GCC/G++/Make Node.js + NPMGNU+Linux &amp; Mac OSXwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bashClose your shell and open an new one. Now that you can call the nvm program, install Node.js (which comes with NPM): nvm install --ltsBuild DependenciesGNU+LinuxDebian / Ubuntu / Mint / Trisquel / and Friends apt install git python build-essentialRed Hat / Fedora / CentOS yum groupinstall 'Development Tools'You might also find yourself lacking a C++11 compiler - see this. Mac OSXxcode-select --installDaemon + Utilities CLIThis package exposes two command line programs: orc and orctool. To install these, use the --global flag. npm install -g @orcproject/orcCore LibraryThis package exposes a module providing a complete implementation of the protocol. To use it in your project, from your project's root directory, install as a dependency. npm install @orcproject/orc --save × Search results Close "},"tutorial-usage.html":{"id":"tutorial-usage.html","title":"Tutorial: Basic Usage Guide","body":" ORC Modules orcorc/constantsorc/profilesorc/utilsorc/version Classes AuditBridgeContractorc/profiles~FarmerProfileorc/profiles~Profileorc/profiles~RenterProfileNodeOffersProofRulesServerShardsTransport Events Offers#event:dataOffers#event:endOffers#event:errorServer#event:errorServer#event:shardDownloadedServer#event:shardUploadedTransport#event:downloadTransport#event:upload Tutorials Configuration GuideManual InstallationBasic Usage Guide Basic Usage Guide The easiest way to get up and running with orc is to spawn a child process from your program and connect to it over the control port. This package exposes a convenience method for doing this. const orc = require('@orcproject/orc'); const { child, controller } = orc(config); // The `config` argument can be either a string path to config file to use or // a JSON dictionary of config properties. See configuration documentaion. child.stdout.pipe(process.stdout); // Pipe log out put to stdout controller.on('ready', () =&gt; { controller.invoke('ping', [contact], console.log); // Ping a contact });Control InterfaceYou can run orc standalone and control it from any other application over its TCP control interface. See the Resources section below to read up on the control protocol to implement it in the language of your choice. If using Node.js, you can use the client bundled in this package. const orc = require('@orcproject/orc'); const controller = new orc.control.Client(); controller.on('ready', () =&gt; { controller.invoke('ping', [contact], (err) =&gt; { /* handle result */ }); }); controller.connect(port);If you wish to control your orc node from another language, simply connect to the control port over a TCP socket and use the BOSCAR protocol to send RPC messages to the node. The methods and argument signatures map directly to the orc.Node API describe in the documentation. See Resources below. Direct ImplementationSince orc exposes all of the internals used to implement it, you can use the same classes to directly implement your own ORC node within your project. Just import the package and construct a node instance with options. const orc = require('@orcproject/orc'); const node = new orc.Node(options); node.listen(8443); node.join(['known_node_id', { /* contact data */ }]);Consult the documentation for a complete reference of the API exposed from the Node object. Further documentation on usage can be found by reviewing the end-to-end test suite in test/node.e2e.js. Note that using this package as a library provides a very low level interface for the ORC protocol and is not intended for casual integration with the ORC network. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
